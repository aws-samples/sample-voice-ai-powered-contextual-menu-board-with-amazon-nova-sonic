{
  "exportVersion": "1.0",
  "exportDate": "2025-09-26T05:05:13.883Z",
  "appVersion": "1.0.0",
  "settings": {
    "cognito": {
      "userPoolId": "us-east-1_jQtehUKpR",
      "userPoolClientId": "5ku2niqnrslu176ilag62knt66",
      "identityPoolId": "us-east-1:65631f53-a3e9-4a3d-b4b2-3e117cb8463a",
      "region": "us-east-1"
    },
    "agent": {
      "system_prompt": "You are a Hotel Room Service Concierge. Your goal is to assist hotel guests with their in-room service requests using professional and courteous communication to fulfill their needs.\n\nCRITICAL FIRST STEP: Before providing ANY services, you MUST collect the guest's room number using the GetRoomNumber tool. Do not proceed with any service requests until the room number is confirmed.\n\nSteps to Successfully Handle a Room Service Request:\nStep 1. Always provide a warm, professional welcome and immediately ask for the guest's room number.\nStep 2. Validate and store the room number, then call GetCustomerLoyaltyInfo to get details about their status.\nStep 3. PERSONALIZED GREETING: After GetRoomNumber tool succeeds, provide a personalized greeting based on the returned guest and loyalty information and then ask what service category they would like to request:\n   - If guest info found: \"Welcome back, [Guest Name]! Thank you for staying with us in Room [Number].\"\n   - If loyalty info found: Add \"As a [Status] member with [Points] points, we're delighted to serve you.\"\n   - If no guest info: Use standard greeting \"Thank you for choosing our hotel for Room [Number].\"\nStep 4. Listen carefully and politely acknowledge what you've heard from the guest before using any tools.\nStep 5. Get the entire menu using the GetMenuItems for you to get the full list of available products.\nStep 6. Analyze the guest's request and execute the appropriate tools to assist them.\nStep 7. After adding items to cart, ask the guest to review their order and confirm before submitting.\nStep 8. Always ask for confirmation before submitting any orders - never auto-submit\nStep 9. For spa services, ensure you collect their preferred time slot and confirm availability before adding to cart.\nStep 10. Provide the guest with estimated delivery/service time and any special instructions.\nStep 11. Only after completing the service request, finalize the session with the appropriate tool.\n\n✅ Pro Tips:\n- Do not ask for room number multiple times - once GetRoomNumber tool succeeds, proceed with services\n- Room number must be 3-4 digits (e.g., 101, 1205)\n- Review the service request with the guest and confirm all details, including any special preferences or customizations\n- For housekeeping services, remind guests these are complimentary hotel amenities\n- If a guest requests a specific customization that doesn't exist in the menu, AUTOMATICALLY use the 'special-instructions' customization to capture their request as additional notes\n- Never tell guests that a customization isn't available - always use special-instructions to capture any custom requests\n- For example: if guest asks for 'mirror cleaning' or 'extra pillows', add these as special-instructions automatically\n- Use professional hospitality language — avoid technical terms or tool/system errors\n- Maintain the luxury hotel experience throughout the interaction\n- Remember: Ask for room number → Call GetRoomNumber tool → Personalized greeting → Proceed with services\n- FOR BEST USER EXPERIENCE proactively use ShowCategoryItems along the interaction, don't wait for the customer to ask you to show them the items in a specific category. ALSO If the customer is interested in a specific category, use it right away.",
      "tools": [
        {
          "tool_name": "GetRoomNumber",
          "description": "Collects and validates the guest's room number, fetches guest information and loyalty status for personalized service. This tool MUST be called before any service requests.",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"roomNumber\": {\n      \"type\": \"string\",\n      \"description\": \"The guest's room number (3-4 digits)\",\n      \"pattern\": \"^\\\\d{3,4}$\"\n    }\n  },\n  \"required\": [\"roomNumber\"]\n}"
          },
          "script": "async function execute({...args}) {\n  const { input, components, toolName, utils, auth, axios, globals } = args;\n  console.log(\"Tool::Script::\" + toolName + \" executed with input:\", JSON.stringify(input, null, 2));\n  \n  try {\n    const roomNumber = input.roomNumber;\n    \n    // Validate room number format\n    if (!roomNumber || !/^\\d{3,4}$/.test(roomNumber)) {\n      components.ui.showNotification(\"Invalid room number format\", \"error\");\n      return JSON.stringify({\n        success: false,\n        error: \"Room number must be 3-4 digits (e.g., 101, 1205)\"\n      });\n    }\n    \n    // Store room number in session\n    utils.storage.setData('guestRoomNumber', roomNumber);\n    \n    // Fetch room booking information\n    let guestInfo = null;\n    let loyaltyInfo = null;\n    \n    try {\n      const tokens = await auth.getTokens();\n      console.log(\"Tool::Script::\" + toolName + \" tokens available:\", tokens ? \"yes\" : \"no\");\n      console.log(\"Tool::Script::\" + toolName + \" idToken exists:\", tokens.idToken ? \"yes\" : \"no\");\n      console.log(\"Tool::Script::\" + toolName + \" roomBookingAPIURL:\", globals.roomBookingAPIURL);\n      \n      if (tokens.idToken && globals.roomBookingAPIURL) {\n        console.log(\"Tool::Script::\" + toolName + \" fetching room booking for:\", roomNumber);\n        \n        const bookingResponse = await axios.get(`${globals.roomBookingAPIURL}?roomNumber=${roomNumber}`, {\n          headers: {\n            \"Authorization\": `${tokens.idToken}`,\n            \"Content-Type\": \"application/json\"\n          }\n        });\n        \n        console.log(\"Tool::Script::\" + toolName + \" booking API response status:\", bookingResponse.status);\n        console.log(\"Tool::Script::\" + toolName + \" booking API response data:\", JSON.stringify(bookingResponse.data, null, 2));\n        \n        if (bookingResponse.data.found) {\n          guestInfo = bookingResponse.data.booking;\n          console.log(\"Tool::Script::\" + toolName + \" found guest:\", guestInfo.guestName);\n          console.log(\"Tool::Script::\" + toolName + \" guest phone:\", guestInfo.phone);\n          console.log(\"Tool::Script::\" + toolName + \" guest customerId:\", guestInfo.customerId);\n          \n          // Store guest info in session\n          utils.storage.setData('guestInfo', JSON.stringify(guestInfo));\n          \n          // Fetch loyalty information using phone (primary) or customerId (fallback)\n          if (globals.loyaltyAPIURL) {\n            let loyaltyURL = null;\n            let lookupMethod = null;\n            \n            if (guestInfo.phone) {\n              loyaltyURL = `${globals.loyaltyAPIURL}?phone=${encodeURIComponent(guestInfo.phone)}`;\n              lookupMethod = \"phone\";\n            } else if (guestInfo.customerId) {\n              loyaltyURL = `${globals.loyaltyAPIURL}?customerId=${guestInfo.customerId}`;\n              lookupMethod = \"customerId\";\n            }\n            \n            if (loyaltyURL) {\n              console.log(\"Tool::Script::\" + toolName + \" fetching loyalty using\", lookupMethod + \":\", loyaltyURL);\n              \n              const loyaltyResponse = await axios.get(loyaltyURL, {\n                headers: {\n                  \"Authorization\": `${tokens.idToken}`,\n                  \"Content-Type\": \"application/json\"\n                }\n              });\n              \n              console.log(\"Tool::Script::\" + toolName + \" loyalty API response status:\", loyaltyResponse.status);\n              console.log(\"Tool::Script::\" + toolName + \" loyalty API response data:\", JSON.stringify(loyaltyResponse.data, null, 2));\n              \n              if (loyaltyResponse.data.found) {\n                loyaltyInfo = loyaltyResponse.data.customer;\n                console.log(\"Tool::Script::\" + toolName + \" found loyalty status:\", loyaltyInfo.loyaltyStatus);\n                console.log(\"Tool::Script::\" + toolName + \" loyalty points:\", loyaltyInfo.loyaltyPoints);\n                console.log(\"Tool::Script::\" + toolName + \" customer name:\", loyaltyInfo.name);\n                \n                // Store loyalty info in session\n                utils.storage.setData('loyaltyInfo', JSON.stringify(loyaltyInfo));\n              } else {\n                console.log(\"Tool::Script::\" + toolName + \" loyalty not found for\", lookupMethod);\n              }\n            } else {\n              console.log(\"Tool::Script::\" + toolName + \" no phone or customerId available for loyalty lookup\");\n            }\n          } else {\n            console.log(\"Tool::Script::\" + toolName + \" loyaltyAPIURL not configured\");\n          }\n        } else {\n          console.log(\"Tool::Script::\" + toolName + \" room booking not found for room:\", roomNumber);\n        }\n      } else {\n        console.log(\"Tool::Script::\" + toolName + \" missing tokens or roomBookingAPIURL\");\n      }\n    } catch (apiError) {\n      console.error(\"Tool::Script::\" + toolName + \" API error:\", apiError);\n      console.error(\"Tool::Script::\" + toolName + \" API error message:\", apiError.message);\n      console.error(\"Tool::Script::\" + toolName + \" API error response:\", apiError.response?.data);\n      console.error(\"Tool::Script::\" + toolName + \" API error status:\", apiError.response?.status);\n    }\n    \n    // Show success notification\n    if (guestInfo && loyaltyInfo) {\n      components.ui.showNotification(\n        `Welcome back, ${guestInfo.guestName}! ${loyaltyInfo.loyaltyStatus} member confirmed for Room ${roomNumber}`, \n        \"success\"\n      );\n    } else if (guestInfo) {\n      components.ui.showNotification(\n        `Room ${roomNumber} confirmed for ${guestInfo.guestName}`, \n        \"success\"\n      );\n    } else {\n      components.ui.showNotification(\n        `Room ${roomNumber} confirmed`, \n        \"success\"\n      );\n    }\n    \n    console.log(\"Tool::Script::\" + toolName + \" final result - guestInfo:\", guestInfo ? \"found\" : \"not found\");\n    console.log(\"Tool::Script::\" + toolName + \" final result - loyaltyInfo:\", loyaltyInfo ? \"found\" : \"not found\");\n    \n    return JSON.stringify({\n      success: true,\n      roomNumber: roomNumber,\n      guestInfo: guestInfo,\n      loyaltyInfo: loyaltyInfo,\n      message: guestInfo ? \n        `Room ${roomNumber} confirmed for ${guestInfo.guestName}` : \n        `Room ${roomNumber} confirmed`\n    });\n    \n  } catch (error) {\n    console.error(\"Tool::Script::\" + toolName + \" error:\", error);\n    components.ui.showNotification(\"Failed to validate room number\", \"error\");\n    return JSON.stringify({\n      success: false,\n      error: error.message\n    });\n  }\n}\n",
          "run_after_app_init": false,
          "order": 1
        },
        {
          "tool_name": "GetDateAndTime",
          "description": "This tool will return the date and time for agent awareness",
          "inputSchema": {
            "json": "{\n    \"type\": \"object\",\n    \"properties\": {},\n    \"required\": []\n}"
          },
          "script": "// Your JavaScript code here\nasync function execute({...args}) {\n  const { input, sessionId, toolName, ...components} = args;\n  console.log(\"Tool::Script::\"+toolName+\" executed with args:\", args);\n\n  // Using America/Chicago for UTC-6 (Central Time)\n  const date = new Date().toLocaleString(\"en-US\", { timeZone: \"America/Chicago\" });\n  const ctDate = new Date(date);\n  return JSON.stringify({ date: ctDate.toISOString() });\n}",
          "run_after_app_init": false,
          "order": 2
        },
        {
          "tool_name": "GetMenuItems",
          "description": "This tool will pull all the menu items with all their attributes, it will also contain the item id that you can use in the cart",
          "inputSchema": {
            "json": "{\n    \"type\": \"object\",\n    \"properties\": {},\n    \"required\": []\n}"
          },
          "script": "async function execute({...args}) {\n  const { agentTriggered, axios, components, auth, toolName, globals, utils } = args;\n  //console.log(\"Tool::Script::\"+ toolName +\" with input:\", args);\n  \n  try {\n    // Show loading notification\n    components.ui.showNotification(\"Retriving menu...\", \"info\");\n    // Get Cognito access token for API Gateway authentication\n    const tokens = await auth.getTokens();\n    if (!tokens.idToken) {\n      throw new Error(\"No access token available\");\n    }\n\n    console.log(\"Tool::Script::\"+ toolName +\" idToken:\", tokens.idToken);\n\n    // Make authenticated API call to your API Gateway\n    const menu = utils.storage.getData('cachedMenu');\n    var response = {};\n    if(!menu){\n      response = await axios.get(globals.menuAPIURL, {\n        headers: {\n          \"Authorization\": `${tokens.idToken}`,\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      utils.storage.setData('cachedMenu', JSON.stringify(response), 2);\n      console.log(\"Tool::Script::\"+ toolName +\" storing menu in cache\");\n    }else{\n      console.log(\"Tool::Script::\"+ toolName +\" get menu from cache\");\n      response = JSON.parse(menu);\n    }\n    \n    \n    var items = [];\n    if(response.data.items.length){\n      items = [...new Set(response.data.items.map((item) => {\n        return {\n          ...item,\n          available: true,\n        }\n      }))]\n    }\n    \n    // Avoid reloading elements in the view\n    // Only if is not triggered by the agent, the menu will be cleared out\n    if(!agentTriggered){\n      // Clear existing menu and add sample items\n      components.menu.clearMenu();\n      components.menu.addItems(items);\n      \n      // Show success notification\n      components.ui.showNotification(\n        `Loaded ${items.length} menu items successfully!`, \n        \"success\"\n      );\n\n      components.menu.setActiveCategory(\"All Items\");\n\n    }else{\n      // Show success notification\n      components.ui.showNotification(\n        `The agent got the updated menu!`, \n        \"success\"\n      );\n    }\n    \n    const result = JSON.stringify({\n      success: true,\n      itemsLoaded: items.length,\n      categories: components.menu.getAllCategories(),\n      menu: [... new Set(items.map((item) => {\n        // Avoid image urls to be returned to the model for token optimization.\n        return {\n          ...item,\n          image: null\n        };\n      }))]\n    });\n    \n    return result;\n    \n  } catch (error) {\n    components.ui.showNotification(\"Failed to load sample menu\", \"error\");\n    console.log(\"Tool::Script::\"+toolName+\" error:\", error);\n    return JSON.stringify({\n      success: false,\n      error: error.message\n    });\n  }\n}",
          "run_after_app_init": true,
          "order": 3
        },
        {
          "tool_name": "AddToCart",
          "description": "This tool will allow adding items to the cart. It requires for you to read the 'id' associated to the item selected by the customer from the menu. ",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"description\": \"Array of items that are needed to be added to the cart\",\n  \"properties\": {\n    \"items\": {\n      \"type\": \"array\",\n      \"properties\": {\n        \"itemId\": {\n          \"type\": \"string\",\n          \"description\": \"This is the id of the item to add from the menu items\"\n        },\n        \"quantity\": {\n          \"type\": \"number\",\n          \"description\": \"Quantity to add\",\n          \"default\": 1\n        },\n        \"customizations\": {\n          \"type\": \"array\",\n          \"description\": \"Array of customization IDs to apply to the item\",\n          \"items\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"id\": { \n                \"type\": \"string\",\n                \"description\": \"The customization ID from the menu item's availableCustomizations\"\n              }\n            },\n            \"required\": [\"id\"]\n          }\n        }\n      },\n      \"required\": [\"itemId\"]\n    }\n  },\n  \"required\": [\"items\"]\n}"
          },
          "script": "async function execute({...args}) {\n  const { input, components, toolName, utils, auth, axios, globals } = args;\n  console.log(\"Tool::Script::\"+toolName+\" executed with input:\", JSON.stringify(input, null, 2));\n\n  // Helper function to check if two customization arrays are the same\n  const customizationsMatch = (customizations1, customizations2) => {\n    if (!customizations1 && !customizations2) return true;\n    if (!customizations1 || !customizations2) return false;\n    if (customizations1.length !== customizations2.length) return false;\n    \n    // Sort both arrays by id for comparison\n    const sorted1 = [...customizations1].sort((a, b) => a.id.localeCompare(b.id));\n    const sorted2 = [...customizations2].sort((a, b) => a.id.localeCompare(b.id));\n    \n    return sorted1.every((custom1, index) => custom1.id === sorted2[index].id);\n  };\n\n  // Helper function to find existing cart item with same menuItemId and customizations\n  const findExistingCartItem = (menuItemId, customizations) => {\n    const currentCart = components.cart.getOrderSummary();\n    console.log(\"Tool::Script::\"+toolName+\" Current Order Summary:\", currentCart);\n    console.log(\"Tool::Script::\"+toolName+\" Requested MenuItemID:\", menuItemId);\n    console.log(\"Tool::Script::\"+toolName+\" Requested customizations:\", customizations);\n\n    // Log each cart item for debugging (not the cart summary itself)\n    if (currentCart.items && currentCart.items.length > 0) {\n      currentCart.items.forEach((cartItem, index) => {\n        console.log(\"Tool::Script::\"+toolName+\" Cart Item\", index, \"MenuItemID:\", cartItem.menuItemId);\n        console.log(\"Tool::Script::\"+toolName+\" Cart Item\", index, \"customizations:\", cartItem.customizations);\n      });\n    } else {\n      console.log(\"Tool::Script::\"+toolName+\" Cart is empty\");\n    }\n\n    \n    return currentCart.items.find(cartItem => \n      cartItem.menuItemId === menuItemId && \n      customizationsMatch(cartItem.customizations, customizations)\n    );\n  };\n  \n  try {\n    if(input.items.length === 0){\n      throw(\"No items passed to the tool, at least one item is needed\");\n    }\n\n    const items = input.items;\n    const itemsToAdd = [];\n    const itemsToUpdate = [];\n    const processedItems = [];\n    \n    // Initialize cartResult and comboApplied at the top\n    let cartResult = null;\n    let comboApplied = null;\n\n    // Adding items in the array one by one to the cart\n    for(const element of items){\n      // Search for the item by id\n      console.log(\"Tool::Script::\"+toolName+\" getItemById:\", element.itemId);\n      let item = components.menu.getItemById(element.itemId);\n      console.log(\"Tool::Script::\"+toolName+\" Retrieved Item :\", item);\n\n      //If the item could be found, we will try to search for it, in case the agent made a mistake while providing the id\n      if(!item){\n        console.log(\"Tool::Script::\"+toolName+\" no item found using id:\", element.itemId);\n        components.ui.showNotification(`Searching for item \"${element.itemId}\" `, \"info\");\n\n        const searchResult = components.menu.searchItems(element.itemId);\n        \n        console.log(\"Tool::Script::\"+toolName+\" product found for cart\", searchResult);\n\n        if(searchResult.length > 1){\n          return JSON.stringify({\n            success: true,\n            message: \"Confirm with the customer which menu item he is referring to\",\n            products: searchResult\n          });\n        }else{\n          console.log(\"Tool::Script::\"+toolName+\" product found for cart\", searchResult);\n          item = searchResult[0]\n        }\n      }\n\n      // If the item was not found despite the effort of searching for it\n      if (!item) {\n        components.ui.showNotification(`Item \"${element.itemId}\" not found`, \"error\");\n        return JSON.stringify({\n          success: false,\n          error: `Item '${element.itemId}' not found in menu`\n        });\n      }\n\n      // ========================================\n      // IMPROVED CUSTOMIZATION VALIDATION\n      // ========================================\n      \n      const customizations = [];\n      \n      try {\n        if (Array.isArray(element.customizations) && element.customizations.length > 0) {\n          console.log(\"Tool::Script::\"+toolName+\" validating customizations for:\", item.name);\n          console.log(\"Tool::Script::\"+toolName+\" requested customizations:\", element.customizations);\n          console.log(\"Tool::Script::\"+toolName+\" available customizations:\", item.availableCustomizations);\n          \n          // Validate each customization individually\n          for (const cRequested of element.customizations) {\n            const foundCustomization = item.availableCustomizations.find(cAvailable => \n              cRequested.id === cAvailable.id\n            );\n           \n            if (!foundCustomization) {\n              // Invalid customization - provide meaningful feedback\n              const availableCustomizationNames = item.availableCustomizations.length > 0 \n                ? item.availableCustomizations.map(c => c.name).join(', ')\n                : 'none';\n              \n              const errorMessage = item.availableCustomizations.length > 0\n                ? `\"${cRequested.id}\" customization is not available for ${item.name}. Available customizations: ${availableCustomizationNames}`\n                : `${item.name} does not have any customizations available`;\n              \n              console.log(\"Tool::Script::\"+toolName+\" CUSTOMIZATION ERROR:\", errorMessage);\n              \n              // Show user notification\n              components.ui.showNotification(\n                `Invalid customization: ${cRequested.id} not available for ${item.name}`, \n                \"error\"\n              );\n              \n              return JSON.stringify({\n                success: false,\n                error: errorMessage,\n                itemName: item.name,\n                requestedCustomization: cRequested.id,\n                availableCustomizations: item.availableCustomizations.map(c => ({\n                  id: c.id,\n                  name: c.name,\n                  price: c.price,\n                  isRemoval: c.isRemoval || false\n                })),\n                suggestion: item.availableCustomizations.length > 0 \n                  ? `Please choose from: ${availableCustomizationNames}`\n                  : `${item.name} cannot be customized`\n              });\n            }\n            \n            // Valid customization - add it\n            customizations.push(foundCustomization);\n            console.log(\"Tool::Script::\"+toolName+\" valid customization added:\", foundCustomization.name);\n          }\n        }\n        \n        console.log(\"Tool::Script::\"+toolName+\" final validated customizations:\", customizations);\n        \n      } catch(e) {\n        console.error(\"Tool::Script::\"+toolName+\" customization validation error:\", e);\n        return JSON.stringify({\n          success: false,\n          error: `Error processing customizations for ${item.name}: ${e.message}`\n        });\n      }\n\n      // If the item becomes unavailable, we need to tell that to the agent\n      if (!item.available) {\n        return JSON.stringify({\n          success: false,\n          error: `Item id \"${element.itemId}\" is not available right now, it could be out of stock`\n        });\n      }\n\n      // Check if this item already exists in cart with same customizations\n      console.log(\"Tool::Script::\"+toolName+\" checking for existing cart item with menuItemId:\", item.id, \"and customizations:\", customizations);\n      const existingCartItem = findExistingCartItem(String(item.id), customizations);\n      \n      if (existingCartItem) {\n        // Item exists - update quantity instead of adding new\n        const newQuantity = existingCartItem.quantity + (element.quantity || 1);\n        console.log(\"Tool::Script::\"+toolName+\" found existing item:\", existingCartItem.name, \"current qty:\", existingCartItem.quantity, \"adding:\", element.quantity, \"new total:\", newQuantity);\n        \n        itemsToUpdate.push({\n          cartItemId: existingCartItem.id,\n          itemName: existingCartItem.name,\n          oldQuantity: existingCartItem.quantity,\n          addedQuantity: element.quantity || 1,\n          newQuantity: newQuantity\n        });\n        \n        // Use updateQuantity to merge\n        console.log(\"Tool::Script::\"+toolName+\" calling updateQuantity for existing item\");\n        const updateResult = components.cart.updateQuantity(existingCartItem.id, newQuantity);\n        cartResult = { summary: updateResult };\n        \n        // Show success notification for merge\n        components.ui.showNotification(\n          `Added ${element.quantity || 1}x ${item.name} to existing cart item (${newQuantity} total)`, \n          \"success\"\n        );\n        \n      } else {\n        // Item doesn't exist - add as new item\n        console.log(\"Tool::Script::\"+toolName+\" no existing item found, adding as new item\");\n        \n        item.menuItemId = String(item.id);\n        item.quantity = element.quantity || 1;\n        item.customizations = customizations; // Now guaranteed to be valid\n        itemsToAdd.push(item);\n        \n        // Show success notification for new item\n        const customizationText = customizations.length > 0 \n          ? ` with ${customizations.map(c => c.name).join(', ')}`\n          : '';\n        \n        components.ui.showNotification(\n          `Added ${item.quantity}x ${item.name}${customizationText} to cart`, \n          \"success\"\n        );\n      }\n      \n      // Highlight the item in the menu\n      components.menu.highlightItem(item.id, 3000);\n      \n      processedItems.push({\n        itemId: element.itemId,\n        itemName: item.name,\n        quantity: element.quantity || 1,\n        action: existingCartItem ? 'merged' : 'added',\n        customizations: customizations\n      });   \n    }\n\n    // Add new items to cart (if any) and capture combo information\n    if (itemsToAdd.length > 0) {\n      console.log(\"Tool::Script::\"+toolName+\" adding\", itemsToAdd.length, \"new items to cart\");\n      cartResult = components.cart.bulkAddToCart(itemsToAdd);\n      console.log(\"Tool::Script::\"+toolName+\" bulkAddToCart result:\", JSON.stringify(cartResult, null, 2));\n      \n      // Check if combo was applied\n      if (cartResult && cartResult.comboApplied) {\n        comboApplied = cartResult.comboApplied;\n        console.log(\"Tool::Script::\"+toolName+\" COMBO DETECTED:\", comboApplied.comboName, \"savings:\", comboApplied.savings);\n        \n        // Show combo notification\n        components.ui.showNotification(\n          `🎉 ${comboApplied.comboName} applied! Saved $${comboApplied.savings.toFixed(2)}`, \n          \"success\"\n        );\n      }\n    }\n\n    // Ensure cartResult is always set\n    if (!cartResult) {\n      cartResult = { summary: components.cart.getOrderSummary() };\n    }\n\n    console.log(\"Tool::Script::\"+toolName+\" final cart result:\", JSON.stringify(cartResult, null, 2));\n\n    // Sending cart item to the API for synchronization (Drive-thru logic with roomNumber)\n    const tokens = await auth.getTokens();\n    const payload = {\n      roomNumber: utils.storage.getData('guestRoomNumber'),\n      loyaltyId: input.loyaltyId || \"null\",\n      cartSummary: JSON.stringify(cartResult.summary).replace(/\"/g, '\\\\\"')\n    }\n    console.log(\"Tool::Script::\"+toolName+\" syncing with API:\", JSON.stringify(payload, null, 2));\n\n    // Fire-and-forget with error handling\n    if (tokens.idToken && globals.cartAPIURL) {\n      axios.post(globals.cartAPIURL, payload, {\n        headers: {\n          \"Authorization\": `${tokens.idToken}`,\n          \"Content-Type\": \"application/json\"\n        }\n      }).then(response => {\n        console.log(\"Tool::Script::\"+toolName+\" cart synced successfully:\", response.data);\n      }).catch(syncError => {\n        console.error(\"Tool::Script::\"+toolName+\" cart sync error:\", syncError);\n        console.error(\"Tool::Script::\"+toolName+\" error details:\", syncError.response?.data);\n        // Don't fail the whole operation if sync fails\n      });\n    } else {\n      console.log(\"Tool::Script::\"+toolName+\" missing tokens or cartAPIURL\");\n    }\n    \n    // Include combo information in the result\n    const result = JSON.stringify({\n      success: true,\n      processedItems: processedItems,\n      newItems: cartResult ? cartResult.addedItems : [],\n      updatedItems: itemsToUpdate,\n      cartSummary: cartResult.summary,\n      ...(comboApplied && { comboApplied })\n    }); \n    \n    console.log(\"Tool::Script::\"+toolName+\" executed with output:\", result);\n    \n    return result;\n    \n  } catch (error) {\n    console.error(\"Tool::Script::\"+toolName+\" error:\", error);\n    components.ui.showNotification(\"Failed to add item to cart\", \"error\");\n    return JSON.stringify({\n      success: false,\n      error: error.message\n    });\n  }\n}",
          "run_after_app_init": false,
          "order": 4
        },
        {
          "tool_name": "addCustomizationToCartItem",
          "description": "This tools will add customization to an item previously added to the cart using the cartItemId",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"cartItemId\": {\n      \"type\": \"string\",\n      \"description\": \"Optional: Specific cart item ID to modify\"\n    },\n    \"itemDescription\": {\n      \"type\": \"string\",\n      \"description\": \"Optional: Item description when customer doesn't specify exact item (e.g., 'fresh bed linens')\"\n    },\n    \"customizations\": {\n      \"type\": \"array\",\n      \"description\": \"Array of customization IDs to add\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": {\n            \"type\": \"string\"\n          }\n        },\n        \"required\": [\n          \"id\"\n        ]\n      }\n    }\n  },\n  \"required\": [\n    \"customizations\"\n  ],\n  \"oneOf\": [\n    {\n      \"required\": [\n        \"cartItemId\"\n      ]\n    },\n    {\n      \"required\": [\n        \"itemDescription\"\n      ]\n    }\n  ]\n}"
          },
          "script": "async function execute({...args}) {\n  const { input, toolName, components, auth, axios, globals, utils } = args;\n\n  console.log(\"Tool::Script::\"+toolName+\" executed input:\", input);\n  \n  try {\n    const cartItem = components.cart.getCartItem(input.cartItemId);\n    if (!cartItem) {\n      return JSON.stringify({\n        success: false,\n        error: \"Cart item not found\"\n      });\n    }\n    \n    console.log(\"Tool::Script::\"+toolName+\" cart item:\", cartItem);\n    \n    const menuItem = components.menu.getItemById(cartItem.menuItemId);\n    if (!menuItem) {\n      return JSON.stringify({\n        success: false,\n        error: \"Menu item not found\"\n      });\n    }\n    \n    console.log(\"Tool::Script::\"+toolName+\" item to update:\", menuItem);\n    \n    const customizationsToAdd = [];\n    const customizationsToReplace = []; // NEW: Track replacements\n    const alreadyExists = [];\n    const notAvailable = [];\n    \n    if (Array.isArray(input.customizations) && input.customizations.length > 0) {\n      for (const cRequested of input.customizations) {\n        // Find the customization in menu\n        const availableCustomization = menuItem.availableCustomizations.find(cAvailable => \n          cRequested.id === cAvailable.id\n        );\n        \n        if (!availableCustomization) {\n          notAvailable.push(cRequested.id);\n          continue;\n        }\n        \n        // Check if customization already exists on cart item\n        const existingCustomization = cartItem.customizations.find(existing => \n          existing.id === cRequested.id\n        );\n        \n        if (existingCustomization) {\n          alreadyExists.push(availableCustomization.name);\n          console.log(\"Tool::Script::\"+toolName+\" customization already exists:\", availableCustomization.name);\n          continue;\n        }\n        \n        // NEW: Check for mutually exclusive customizations\n        const conflictingCustomization = cartItem.customizations.find(existing => {\n          const existingId = existing.id.toLowerCase();\n          const newId = availableCustomization.id.toLowerCase();\n          \n          // Linen types are mutually exclusive\n          if ((existingId.includes('linen-') || existingId.includes('linens-')) && \n              (newId.includes('linen-') || newId.includes('linens-'))) {\n            return true;\n          }\n          \n          // Towel types are mutually exclusive  \n          if ((existingId.includes('towel-') || existingId.includes('towels-')) && \n              (newId.includes('towel-') || newId.includes('towels-'))) {\n            return true;\n          }\n          \n          return false;\n        });\n        \n        if (conflictingCustomization) {\n          // This is a replacement scenario\n          customizationsToReplace.push({\n            oldCustomization: conflictingCustomization,\n            newCustomization: availableCustomization\n          });\n          console.log(\"Tool::Script::\"+toolName+\" will replace:\", conflictingCustomization.name, \"with:\", availableCustomization.name);\n        } else {\n          // This is a new addition\n          customizationsToAdd.push(availableCustomization);\n          console.log(\"Tool::Script::\"+toolName+\" will add customization:\", availableCustomization.name);\n        }\n      }\n    }\n    \n    // Handle errors\n    if (notAvailable.length > 0) {\n      return JSON.stringify({\n        success: false,\n        error: `Customizations not available: ${notAvailable.join(', ')}`,\n        availableCustomizations: menuItem.availableCustomizations.map(c => ({\n          id: c.id,\n          name: c.name,\n          price: c.price\n        }))\n      });\n    }\n    \n    let item = cartItem;\n    const addedCustomizations = [];\n    const replacedCustomizations = []; // NEW: Track what was replaced\n    \n    // NEW: Handle replacements first\n    for (const replacement of customizationsToReplace) {\n      // Remove old customization\n      await components.cart.removeCustomizationFromCartItem(input.cartItemId, replacement.oldCustomization.id);\n      // Add new customization\n      item = await components.cart.addCustomizationToCartItem(input.cartItemId, replacement.newCustomization);\n      \n      replacedCustomizations.push({\n        old: replacement.oldCustomization.name,\n        new: replacement.newCustomization.name\n      });\n      console.log(\"Tool::Script::\"+toolName+\" replaced:\", replacement.oldCustomization.name, \"with:\", replacement.newCustomization.name);\n    }\n    \n    // Add only new customizations\n    for (const customization of customizationsToAdd) {\n      item = await components.cart.addCustomizationToCartItem(input.cartItemId, customization);\n      addedCustomizations.push(customization.name);\n      console.log(\"Tool::Script::\"+toolName+\" added customization:\", customization.name);\n    }\n    \n    // Show appropriate notifications\n    if (replacedCustomizations.length > 0) {\n      const replacementText = replacedCustomizations.map(r => `${r.old} → ${r.new}`).join(', ');\n      components.ui.showNotification(\n        `Updated ${cartItem.name}: ${replacementText}`,\n        \"success\"\n      );\n    }\n    \n    if (addedCustomizations.length > 0) {\n      components.ui.showNotification(\n        `Added ${addedCustomizations.join(', ')} to ${cartItem.name}`,\n        \"success\"\n      );\n    }\n    \n    if (alreadyExists.length > 0) {\n      components.ui.showNotification(\n        `${alreadyExists.join(', ')} already on ${cartItem.name}`,\n        \"info\"\n      );\n    }\n    \n    const orderSummary = components.cart.getOrderSummary();\n    \n    // Sending cart item to the API for synchronization\n    const tokens = await auth.getTokens();\n    const payload = {\n      roomNumber: utils.storage.getData('guestRoomNumber'),\n      loyaltyId: input.loyaltyId || \"null\",\n      cartSummary: JSON.stringify(orderSummary).replace(/\"/g, '\\\\\"')\n    }\n    console.log(\"Tool::Script::\"+toolName+\" syncing with API:\", JSON.stringify(payload, null, 2));\n\n    // Fire-and-forget with error handling\n    if (tokens.idToken && globals.cartAPIURL) {\n      axios.post(globals.cartAPIURL, payload, {\n        headers: {\n          \"Authorization\": `${tokens.idToken}`,\n          \"Content-Type\": \"application/json\"\n        }\n      }).then(response => {\n        console.log(\"Tool::Script::\"+toolName+\" cart synced successfully:\", response.data);\n      }).catch(syncError => {\n        console.error(\"Tool::Script::\"+toolName+\" cart sync error:\", syncError);\n        console.error(\"Tool::Script::\"+toolName+\" error details:\", syncError.response?.data);\n        // Don't fail the whole operation if sync fails\n      });\n    } else {\n      console.log(\"Tool::Script::\"+toolName+\" missing tokens or cartAPIURL\");\n    }\n    \n    return JSON.stringify({ \n      success: true,\n      result: \"success\",\n      message: [\n        ...replacedCustomizations.map(r => `Replaced ${r.old} with ${r.new}`),\n        ...addedCustomizations.map(c => `Added ${c}`),\n        ...alreadyExists.map(c => `${c} already existed`)\n      ].join('; ') || \"No changes made\",\n      addedCustomizations: addedCustomizations,\n      replacedCustomizations: replacedCustomizations,\n      alreadyExisted: alreadyExists,\n      itemModified: item,\n      cartSummary: orderSummary\n    });\n    \n  } catch (error) {\n    console.error(\"Tool::Script::\"+toolName+\" error:\", error);\n    components.ui.showNotification(\"Failed to add customization\", \"error\");\n    return JSON.stringify({\n      success: false,\n      error: error.message\n    });\n  }\n}",
          "run_after_app_init": false,
          "order": 5
        },
        {
          "tool_name": "RemoveItemFromCart",
          "description": "This tool will help you remove an item that was incorrectly added to the cart, you can also use it to modify and incorrect entry by removing and adding the item correctly typed",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"description\": \"Remove items from cart using either exact cart item IDs or natural language descriptions\",\n  \"properties\": {\n    \"items\": {\n      \"type\": \"array\",\n      \"description\": \"Array of items to remove using exact cart item IDs (existing format)\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"cartItemId\": {\n            \"type\": \"string\",\n            \"description\": \"Exact ID of the cart item to remove\"\n          },\n          \"quantity\": {\n            \"type\": \"number\",\n            \"description\": \"Quantity to remove\"\n          }\n        },\n        \"required\": [\"cartItemId\", \"quantity\"]\n      }\n    },\n    \"itemsToRemove\": {\n      \"type\": \"array\", \n      \"description\": \"Array of items to remove using natural language descriptions (smart format)\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"itemDescription\": {\n            \"type\": \"string\",\n            \"description\": \"Natural language description of item to remove (e.g., 'burger combo', 'the cheese burger', 'combo')\"\n          },\n          \"quantity\": {\n            \"type\": \"number\",\n            \"description\": \"Quantity to remove\",\n            \"default\": 1\n          }\n        },\n        \"required\": [\"itemDescription\"]\n      }\n    }\n  },\n  \"oneOf\": [\n    {\"required\": [\"items\"]},\n    {\"required\": [\"itemsToRemove\"]}\n  ]\n}"
          },
          "script": "async function execute({...args}) {\n  const { input, components, toolName, utils, auth, axios, globals } = args;\n  console.log(\"Tool::Script::\" + toolName + \" executed with input:\", JSON.stringify(input, null, 2));\n  \n  try {\n    // Check if using existing format (cartItemId)\n    if (input.items && Array.isArray(input.items) && input.items.length > 0 && input.items[0].cartItemId) {\n      console.log(\"Tool::Script::\" + toolName + \" using EXISTING format (cartItemId)\");\n      return await executeExistingLogic(input, components, toolName, auth, axios, globals, utils);\n    }\n    \n    // Check if using new smart format (itemDescription)\n    if (input.itemsToRemove && Array.isArray(input.itemsToRemove) && input.itemsToRemove.length > 0) {\n      console.log(\"Tool::Script::\" + toolName + \" using NEW smart format (itemDescription)\");\n      return await executeSmartLogic(input, components, toolName, auth, axios, globals, utils);\n    }\n    \n    throw new Error(\"Invalid input format. Use either 'items' with 'cartItemId' or 'itemsToRemove' with 'itemDescription'\");\n    \n  } catch (error) {\n    console.error(\"Tool::Script::\" + toolName + \" error:\", error);\n    components.ui.showNotification(\"Failed to remove items from cart\", \"error\");\n    return JSON.stringify({\n      success: false,\n      error: error.message\n    });\n  }\n}\n\n// Existing logic (unchanged)\nasync function executeExistingLogic(input, components, toolName, auth, axios, globals, utils) {\n  console.log(\"Tool::Script::\" + toolName + \" EXISTING LOGIC: processing\", input.items.length, \"items\");\n  const processedItems = [];\n  \n  // Initialize cartResult at the top\n  let cartResult = null;\n  \n  for (const element of input.items) {\n    console.log(\"Tool::Script::\" + toolName + \" processing item:\", JSON.stringify(element, null, 2));\n    \n    const cartItem = components.cart.getCartItem(element.cartItemId);\n    console.log(\"Tool::Script::\" + toolName + \" getCartItem result:\", JSON.stringify(cartItem, null, 2));\n    \n    if (!cartItem) {\n      console.error(\"Tool::Script::\" + toolName + \" ERROR: Cart item with ID\", element.cartItemId, \"not found\");\n      components.ui.showNotification(`Cart item with ID \"${element.cartItemId}\" not found in cart`, \"error\");\n      continue;\n    }\n\n    const newQuantity = cartItem.quantity - element.quantity;\n    console.log(\"Tool::Script::\" + toolName + \" quantity calculation:\", cartItem.quantity, \"-\", element.quantity, \"=\", newQuantity);\n    \n    if (newQuantity < 0) {\n      console.error(\"Tool::Script::\" + toolName + \" ERROR: Cannot remove\", element.quantity, \"items. Only\", cartItem.quantity, \"available\");\n      components.ui.showNotification(`Cannot remove ${element.quantity} items. Only ${cartItem.quantity} available in cart`, \"error\");\n      continue;\n    }\n\n    console.log(\"Tool::Script::\" + toolName + \" calling components.cart.updateQuantity with cartItemId:\", element.cartItemId, \"newQuantity:\", newQuantity);\n    const updateResult = components.cart.updateQuantity(element.cartItemId, newQuantity);\n    cartResult = { summary: updateResult };\n    console.log(\"Tool::Script::\" + toolName + \" updateQuantity result:\", JSON.stringify(updateResult, null, 2));\n    \n    processedItems.push({\n      cartItemId: element.cartItemId,\n      itemName: cartItem.name,\n      removedQuantity: element.quantity,\n      newQuantity: newQuantity,\n      action: newQuantity === 0 ? 'removed' : 'updated'\n    });\n\n    if (newQuantity === 0) {\n      console.log(\"Tool::Script::\" + toolName + \" item completely removed\");\n      components.ui.showNotification(`Removed all ${cartItem.name} from cart`, \"success\");\n    } else {\n      console.log(\"Tool::Script::\" + toolName + \" item quantity updated\");\n      components.ui.showNotification(`Removed ${element.quantity}x ${cartItem.name} from cart (${newQuantity} remaining)`, \"success\");\n    }\n  }\n\n  const finalCartSummary = components.cart.getOrderSummary();\n  console.log(\"Tool::Script::\" + toolName + \" final cart summary:\", JSON.stringify(finalCartSummary, null, 2));\n\n  // Ensure cartResult is always set\n  if (!cartResult) {\n    cartResult = { summary: finalCartSummary };\n  }\n\n  // Sending cart item to the API for synchronization\n  const tokens = await auth.getTokens();\n  const payload = {\n    roomNumber: utils.storage.getData('guestRoomNumber'),\n    loyaltyId: input.loyaltyId || \"null\",\n    cartSummary: JSON.stringify(cartResult.summary).replace(/\"/g, '\\\\\"')\n  }\n  console.log(\"Tool::Script::\"+toolName+\" syncing with API:\", JSON.stringify(payload, null, 2));\n\n  // Fire-and-forget with error handling\n  if (tokens.idToken && globals.cartAPIURL) {\n    axios.post(globals.cartAPIURL, payload, {\n      headers: {\n        \"Authorization\": `${tokens.idToken}`,\n        \"Content-Type\": \"application/json\"\n      }\n    }).then(response => {\n      console.log(\"Tool::Script::\"+toolName+\" cart synced successfully:\", response.data);\n    }).catch(syncError => {\n      console.error(\"Tool::Script::\"+toolName+\" cart sync error:\", syncError);\n      console.error(\"Tool::Script::\"+toolName+\" error details:\", syncError.response?.data);\n      // Don't fail the whole operation if sync fails\n    });\n  } else {\n    console.log(\"Tool::Script::\"+toolName+\" missing tokens or cartAPIURL\");\n  }\n\n  const success = processedItems.length > 0;\n  const result = JSON.stringify({\n    success: success,\n    processedItems: processedItems,\n    cartSummary: cartResult.summary\n  }); \n\n  console.log(\"Tool::Script::\" + toolName + \" EXISTING LOGIC executed with output:\", result);\n  return result;\n}\n\n// SIMPLIFIED Smart Logic - Focus on the core issue\nasync function executeSmartLogic(input, components, toolName, auth, axios, globals, utils) {\n  console.log(\"Tool::Script::\" + toolName + \" SMART LOGIC: processing\", input.itemsToRemove.length, \"item descriptions\");\n  \n  // Initialize cartResult at the top\n  let cartResult = null;\n  \n  const currentCart = components.cart.getOrderSummary();\n  console.log(\"Tool::Script::\" + toolName + \" current cart:\", JSON.stringify(currentCart, null, 2));\n  \n  if (!currentCart.items || currentCart.items.length === 0) {\n    components.ui.showNotification(\"Your cart is empty\", \"info\");\n    return JSON.stringify({\n      success: false,\n      error: \"Cart is empty\",\n      cartSummary: currentCart\n    });\n  }\n  \n  const processedItems = [];\n  const clarificationNeeded = [];\n  \n  for (const element of input.itemsToRemove) {\n    const itemDescription = element.itemDescription?.toLowerCase().trim();\n    const requestedQuantity = element.quantity || 1;\n    \n    if (!itemDescription) {\n      console.log(\"Tool::Script::\" + toolName + \" skipping empty item description\");\n      continue;\n    }\n    \n    console.log(\"Tool::Script::\" + toolName + \" looking for:\", itemDescription);\n    \n    // SIMPLE MATCHING LOGIC - Focus on the core issue\n    const matches = currentCart.items.filter(cartItem => {\n      const itemName = cartItem.name.toLowerCase();\n      console.log(\"Tool::Script::\" + toolName + \" checking:\", cartItem.name, \"against:\", itemDescription);\n      \n      // RULE 1: If customer mentions \"with [customization]\", only match items that have that customization\n      if (itemDescription.includes('with ')) {\n        // Extract what they want: \"milkshake with whipped cream\" -> \"whipped cream\"\n        const wantedCustomization = itemDescription.replace(/.*with\\s+/, '').trim();\n        \n        // Only match items that have customizations (~)\n        if (itemName.includes('~')) {\n          const itemCustomizations = itemName.split('~')[1];\n          // Clean up pricing and check if it contains what they want\n          const cleanCustomizations = itemCustomizations\n            .replace(/\\(\\+\\$[\\d.]+\\)/g, '')\n            .replace(/\\(\\-\\$[\\d.]+\\)/g, '')\n            .trim()\n            .toLowerCase();\n          \n          // Check if the customization matches\n          if (cleanCustomizations.includes(wantedCustomization)) {\n            console.log(\"Tool::Script::\" + toolName + \" CUSTOMIZATION match:\", cartItem.name);\n            return true;\n          }\n        }\n        // If they want customization but this item has none, don't match\n        return false;\n      }\n      \n      // RULE 2: If customer says just the base item name, match all variants\n      const baseItemName = itemName.split('~')[0].trim();\n      if (baseItemName.toLowerCase().includes(itemDescription) || itemDescription.includes(baseItemName.toLowerCase())) {\n        console.log(\"Tool::Script::\" + toolName + \" BASE match:\", cartItem.name);\n        return true;\n      }\n      \n      return false;\n    });\n    \n    console.log(\"Tool::Script::\" + toolName + \" found\", matches.length, \"matches for:\", itemDescription);\n    matches.forEach(match => console.log(\"Tool::Script::\" + toolName + \" - Match:\", match.name));\n    \n    if (matches.length === 0) {\n      const availableItems = currentCart.items.map(item => item.name).join(', ');\n      console.log(\"Tool::Script::\" + toolName + \" no matches found\");\n      \n      return JSON.stringify({\n        success: false,\n        error: `\"${element.itemDescription}\" not found in your cart`,\n        availableItems: currentCart.items.map(item => ({\n          id: item.id,\n          name: item.name,\n          quantity: item.quantity\n        })),\n        message: `I don't see \"${element.itemDescription}\" in your cart. Available items: ${availableItems}`,\n        cartSummary: currentCart\n      });\n      \n    } else if (matches.length === 1) {\n      // Single match - remove directly\n      const cartItem = matches[0];\n      console.log(\"Tool::Script::\" + toolName + \" single match found:\", cartItem.name);\n      \n      if (requestedQuantity > cartItem.quantity) {\n        components.ui.showNotification(`Cannot remove ${requestedQuantity}x ${cartItem.name}. Only ${cartItem.quantity} available`, \"error\");\n        continue;\n      }\n      \n      const newQuantity = cartItem.quantity - requestedQuantity;\n      console.log(\"Tool::Script::\" + toolName + \" removing\", requestedQuantity, \"from\", cartItem.quantity, \"=\", newQuantity);\n      \n      const updateResult = components.cart.updateQuantity(cartItem.id, newQuantity);\n      cartResult = { summary: updateResult };\n      console.log(\"Tool::Script::\" + toolName + \" updateQuantity result:\", JSON.stringify(updateResult, null, 2));\n      \n      processedItems.push({\n        cartItemId: cartItem.id,\n        itemName: cartItem.name,\n        removedQuantity: requestedQuantity,\n        newQuantity: newQuantity,\n        action: newQuantity === 0 ? 'removed' : 'updated'\n      });\n      \n      if (newQuantity === 0) {\n        components.ui.showNotification(`Removed all ${cartItem.name} from cart`, \"success\");\n      } else {\n        components.ui.showNotification(`Removed ${requestedQuantity}x ${cartItem.name} from cart (${newQuantity} remaining)`, \"success\");\n      }\n      \n    } else {\n      // Multiple matches - need clarification\n      console.log(\"Tool::Script::\" + toolName + \" multiple matches found, need clarification\");\n      \n      clarificationNeeded.push({\n        requestedItem: element.itemDescription,\n        matches: matches.map(item => ({\n          id: item.id,\n          name: item.name,\n          quantity: item.quantity,\n          price: item.totalPrice\n        }))\n      });\n    }\n  }\n  \n  // Handle clarification - Simple and clear\n  if (clarificationNeeded.length > 0) {\n    const clarificationItem = clarificationNeeded[0];\n    \n    // Create clear descriptions - SIMPLE approach\n    const matchNames = clarificationItem.matches.map((match, index) => {\n      // Simple description with quantity for clarity\n      const hasCustomizations = match.name.includes('~') || match.name.includes('with') || match.name.includes('+');\n      \n      if (hasCustomizations) {\n        return `${match.name} (${match.quantity} qty)`;\n      } else {\n        return `${match.name} (${match.quantity} qty, regular)`;\n      }\n    }).join(' or ');\n    \n    return JSON.stringify({\n      success: false,\n      requiresClarification: true,\n      requestedItem: clarificationItem.requestedItem,\n      matches: clarificationItem.matches,\n      message: `I found ${clarificationItem.matches.length} items matching \"${clarificationItem.requestedItem}\": ${matchNames}. Which one would you like me to remove?`,\n      cartSummary: currentCart\n    });\n  }\n  \n  const finalCartSummary = components.cart.getOrderSummary();\n  console.log(\"Tool::Script::\" + toolName + \" final cart summary:\", JSON.stringify(finalCartSummary, null, 2));\n  \n  // Ensure cartResult is always set\n  if (!cartResult) {\n    cartResult = { summary: finalCartSummary };\n  }\n  \n  // Sending cart item to the API for synchronization\n  const tokens = await auth.getTokens();\n  const payload = {\n    roomNumber: utils.storage.getData('guestRoomNumber'),\n    loyaltyId: input.loyaltyId || \"null\",\n    cartSummary: JSON.stringify(cartResult.summary).replace(/\"/g, '\\\\\"')\n  }\n  console.log(\"Tool::Script::\"+toolName+\" syncing with API:\", JSON.stringify(payload, null, 2));\n\n  // Fire-and-forget with error handling\n  if (tokens.idToken && globals.cartAPIURL) {\n    axios.post(globals.cartAPIURL, payload, {\n      headers: {\n        \"Authorization\": `${tokens.idToken}`,\n        \"Content-Type\": \"application/json\"\n      }\n    }).then(response => {\n      console.log(\"Tool::Script::\"+toolName+\" cart synced successfully:\", response.data);\n    }).catch(syncError => {\n      console.error(\"Tool::Script::\"+toolName+\" cart sync error:\", syncError);\n      console.error(\"Tool::Script::\"+toolName+\" error details:\", syncError.response?.data);\n      // Don't fail the whole operation if sync fails\n    });\n  } else {\n    console.log(\"Tool::Script::\"+toolName+\" missing tokens or cartAPIURL\");\n  }\n  \n  const result = JSON.stringify({\n    success: true,\n    processedItems: processedItems,\n    cartSummary: cartResult.summary,\n    method: \"smart_matching\"\n  });\n  \n  console.log(\"Tool::Script::\" + toolName + \" SMART LOGIC executed with output:\", result);\n  return result;\n}",
          "run_after_app_init": false,
          "order": 6
        },
        {
          "tool_name": "GetCurrentCartItems",
          "description": "The the current cart items and total",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"properties\": {},\n  \"required\": []\n}"
          },
          "script": "async function execute({...args}) {\n  const { toolName, components } = args;\n  const orderSummary = components.cart.getOrderSummary();\n  console.log(\"Tool::Script::\"+toolName+\" current cart:\", orderSummary);\n  // Always return a JSON string\n  return JSON.stringify({ \n    result: \"success\",\n    currentCartItems: orderSummary\n  });\n}",
          "run_after_app_init": false,
          "order": 7
        },
        {
          "tool_name": "ShowCategoryItems",
          "description": "This tool will allow you to keep the conversation in context with what the customer is watching on the screen. Throughout the conversation, you can call this tool to highlight the category you want to bring focus or as an up selling strategy",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"category\": {\n      \"type\": \"string\",\n      \"description\": \"Category to show (e.g., Breakfast, Lunch, Dinner, beverages Spa, Housekeeping, Amenities)\"\n    }\n  },\n  \"required\": [\n    \"category\"\n  ]\n}"
          },
          "script": "async function execute({...args}) {\n  const { input, components } = args;\n  console.log(\"Tool::Script::\"+toolName+\" executed with input:\", input);\n  try {\n    const categories = components.menu.getAllCategories();\n    console.log(\"Tool::Script::\"+toolName+\" All Categories:\", categories);\n    \n    // Find category by name or ID (case insensitive)\n    const targetCategory = categories.find(cat => \n      cat.id.toLowerCase() === input.category.toLowerCase() || \n      cat.name.toLowerCase() === input.category.toLowerCase() ||\n      cat.displayName.toLowerCase() === input.category.toLowerCase()\n    );\n    \n    if (!targetCategory) {\n      const availableCategories = categories.map(cat => cat.displayName).join(', ');\n      components.ui.showNotification(\n        `Category \"${input.category}\" not found. Available: ${availableCategories}`, \n        \"warning\"\n      );\n      const result = JSON.stringify({\n        success: false,\n        error: `Category '${input.category}' not found`,\n        availableCategories: categories.map(cat => cat.displayName)\n      });\n      //console.log(\"Tool::Script::\"+toolName+\" executed with output:\", result);\n      return result;\n    }\n    \n    // Set the active category (same as clicking the category button)\n    components.menu.showCategory(targetCategory.id)\n    components.menu.setActiveCategory(targetCategory.id);\n    \n    // Get items in this category\n    const items = components.menu.getMenuItems(targetCategory.id);\n    //console.log(\"Tool::Script::\"+toolName+\" items:\", JSON.stringify(items,null,2));\n\n    const result = JSON.stringify({\n      success: true,\n      category: targetCategory.displayName,\n      itemCount: items.length,\n      items: items\n    });\n    console.log(\"Tool::Script::\"+toolName+\" executed with output:\", result);\n    return result;\n    \n  } catch (error) {\n    return JSON.stringify({\n      success: false,\n      error: error.message\n    });\n  }\n}",
          "run_after_app_init": false,
          "order": 8
        },
        {
          "tool_name": "GetCategoryList",
          "description": "This tool will allow you to get the list of available categories to avoid errors during the selection of them in another tool. Get this list to keep your conversation in context",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"properties\": {},\n  \"required\": []\n}"
          },
          "script": "async function execute({...args}) {\n  const { components, toolName} = args;\n  const categories = components.menu.getAllCategories();\n  \n  // Always return a JSON string\n  return JSON.stringify({ \n    result: \"success\",\n    categories: categories\n  });\n}",
          "run_after_app_init": false,
          "order": 9
        },
        {
          "tool_name": "SubmitOrder",
          "description": "This tool will be that last one to use when the customer is ready to move for payment. By using this tool, you will be cleaning the chat and cart and leaving the interface ready for the next customer",
          "inputSchema": {
            "json": "{\n  \"tool_name\": \"SubmitOrder\",\n  \"description\": \"Submit the current order to the kitchen and save chat history to database\",\n  \"inputSchema\": {\n    \"type\": \"object\",\n    \"properties\": {},\n    \"required\": []\n  },\n  \"run_after_app_init\": false,\n  \"order\": 20\n}"
          },
          "script": "async function execute({...args}) {\n  const { toolName, components, axios, auth, globals, utils } = args;\n  console.log(\"Tool::Script::\" + toolName + \" executed with args:\", args);\n  \n  try {\n    // Get order summary and chat messages\n    const orderSummary = components.cart.getOrderSummary();\n    const chatMessages = components.chat.getMessagesForStorage();\n    \n    console.log(\"Tool::Script::\" + toolName + \" orderSummary\", orderSummary);\n    console.log(\"Tool::Script::\" + toolName + \" chatMessages\", chatMessages);\n    \n    // Check if room number is stored in session\n    const storedRoomNumber = utils.storage.getData('guestRoomNumber');\n    if (!storedRoomNumber) {\n      components.ui.showNotification(\"Room number required\", \"warning\");\n      return JSON.stringify({\n        success: false,\n        error: \"Room number required\",\n        message: \"Please provide your room number first.\"\n      });\n    }\n    \n    // Get authentication tokens\n    const tokens = await auth.getTokens();\n    if (!tokens.idToken) {\n      throw new Error(\"No access token available\");\n    }\n\n    console.log(\"Tool::Script::\"+ toolName +\" idToken:\", tokens.idToken);\n    \n    // Simple housekeeping detection by name\n    const housekeepingKeywords = ['towel', 'linen', 'cleaning', 'housekeeping', 'laundry', 'pressing'];\n    const housekeepingItems = orderSummary.items.filter(item => {\n      const itemName = (item.name || '').toLowerCase();\n      return housekeepingKeywords.some(keyword => itemName.includes(keyword));\n    });\n    const nonHousekeepingItems = orderSummary.items.filter(item => {\n      const itemName = (item.name || '').toLowerCase();\n      return !housekeepingKeywords.some(keyword => itemName.includes(keyword));\n    });\n    \n    console.log(\"Tool::Script::\" + toolName + \" housekeeping items:\", housekeepingItems.length);\n    console.log(\"Tool::Script::\" + toolName + \" non-housekeeping items:\", nonHousekeepingItems.length);\n    \n    let orderId = null;\n    \n    // Step 1: Submit non-housekeeping items to Order Table (if any)\n    if (nonHousekeepingItems.length > 0) {\n      const orderData = {\n        customerId: \"hotel-guest\",\n        total: orderSummary.total,\n        items: JSON.stringify(nonHousekeepingItems).replace(/\"/g, '\\\\\"'),\n        roomNumber: storedRoomNumber\n      };\n      \n      console.log(\"Tool::Script::\" + toolName + \" sending order data:\", orderData);\n      \n      const orderResponse = await axios.post(\n        globals.orderAPIURL,\n        orderData,\n        {\n          headers: {\n            \"Authorization\": `${tokens.idToken}`,\n            \"Content-Type\": \"application/json\"\n          }\n        }\n      );\n      \n      console.log(\"Tool::Script::\" + toolName + \" order API response:\", orderResponse.data);\n      orderId = orderResponse.data.orderId;\n    } else {\n      // Generate orderId for housekeeping-only requests\n      orderId = `HK-${Date.now()}`;\n    }\n    \n    // Step 2: Submit housekeeping items to Housekeeping Table (if any)\n    let housekeepingSubmitted = 0;\n    if (housekeepingItems.length > 0) {\n      console.log(\"Tool::Script::\" + toolName + \" submitting housekeeping items\");\n      \n      try {\n        const housekeepingData = {\n          requestId: orderId,\n          serviceType: \"housekeeping\",\n          serviceName: housekeepingItems.map(item => item.name).join(\", \"),\n          roomNumber: storedRoomNumber,\n          quantity: housekeepingItems.reduce((sum, item) => sum + (item.quantity || 1), 0),\n          urgency: \"standard\",\n          priority: \"normal\",\n          estimatedTime: \"30 minutes\",\n          preferredTime: \"ASAP\",\n          specialInstructions: housekeepingItems\n            .map(item => {\n              let instructions = \"\";\n              \n              // Handle different customization formats\n              if (item.customizations) {\n                if (Array.isArray(item.customizations)) {\n                  instructions = item.customizations.map(c => c.name || c).join(\", \");\n                } else if (typeof item.customizations === 'string') {\n                  instructions = item.customizations;\n                } else if (typeof item.customizations === 'object') {\n                  instructions = JSON.stringify(item.customizations);\n                }\n              } else if (item.specialInstructions) {\n                instructions = item.specialInstructions;\n              }\n              \n              return instructions ? `${item.name} - ${instructions}` : \"\";\n            })\n            .filter(instruction => instruction)\n            .join(\", \"),\n          requestTime: new Date().toISOString(),\n          status: \"pending\"\n        };\n        \n        await axios.post(\n          globals.housekeepingAPIURL,\n          housekeepingData,\n          {\n            headers: {\n              \"Authorization\": `${tokens.idToken}`,\n              \"Content-Type\": \"application/json\"\n            }\n          }\n        );\n        \n        housekeepingSubmitted = housekeepingItems.length;\n      } catch (housekeepingError) {\n        console.error(\"Tool::Script::\" + toolName + \" housekeeping error:\", housekeepingError);\n      }\n    }\n    \n    // Step 3: Save all chat messages in one batch request\n    if (chatMessages.length > 0) {\n      console.log(\"Tool::Script::\" + toolName + \" saving chat history batch for orderId:\", orderId);\n      \n      const messagesForBatch = chatMessages.map(message => ({\n        orderId: orderId,\n        timestamp: message.createdAt,\n        role: message.role,\n        message: message.message,\n        messageId: message.messageId\n      }));\n      \n      const chatBatchData = {\n        messages: messagesForBatch\n      };\n      \n      console.log(\"Tool::Script::\" + toolName + \" sending chat batch data:\", chatBatchData);\n      \n      const chatResponse = await axios.post(\n        globals.chatAPIURL,\n        chatBatchData,\n        {\n          headers: {\n            \"Authorization\": `${tokens.idToken}`,\n            \"Content-Type\": \"application/json\"\n          }\n        }\n      );\n      \n      console.log(\"Tool::Script::\" + toolName + \" chat batch API response:\", chatResponse.data);\n    }\n    \n    // Step 4: Clear cart and show success\n    components.cart.clearCart();\n    \n    // Step 5: Sync empty cart to DynamoDB\n    const emptyCartSummary = {\n      subtotal: 0,\n      tax: 0,\n      total: 0,\n      items: [],\n      totalQuantity: 0\n    };\n    const cartResult = { summary: emptyCartSummary };\n    const payload = {\n      roomNumber: storedRoomNumber,\n      loyaltyId: \"null\",\n      cartSummary: JSON.stringify(cartResult.summary).replace(/\"/g, '\\\\\"')\n    }\n    console.log(\"Tool::Script::\"+toolName+\" syncing empty cart with API:\", JSON.stringify(payload, null, 2));\n\n    // Fire-and-forget sync to clear backend cart\n    if (tokens.idToken && globals.cartAPIURL) {\n      axios.post(globals.cartAPIURL, payload, {\n        headers: {\n          \"Authorization\": `${tokens.idToken}`,\n          \"Content-Type\": \"application/json\"\n        }\n      }).then(response => {\n        console.log(\"Tool::Script::\"+toolName+\" empty cart synced successfully:\", response.data);\n      }).catch(syncError => {\n        console.error(\"Tool::Script::\"+toolName+\" cart clear sync error:\", syncError);\n        // Don't fail the whole operation if sync fails\n      });\n    } else {\n      console.log(\"Tool::Script::\"+toolName+\" missing tokens or cartAPIURL for cart clear sync\");\n    }\n    \n    // Create appropriate success message\n    let successMessage = \"\";\n    let confirmationMessage = \"\";\n    \n    if (nonHousekeepingItems.length > 0 && housekeepingItems.length > 0) {\n      successMessage = `Order submitted! Food sent to kitchen, ${housekeepingSubmitted} housekeeping requests sent to staff.`;\n      confirmationMessage = `Order #${orderId} - Food: $${orderSummary.total.toFixed(2)}, Housekeeping: ${housekeepingSubmitted} requests`;\n    } else if (nonHousekeepingItems.length > 0) {\n      successMessage = \"Order submitted successfully! Your food and drinks have been sent to the kitchen.\";\n      confirmationMessage = `Order #${orderId} has been sent to the kitchen. Total: $${orderSummary.total.toFixed(2)}`;\n    } else if (housekeepingItems.length > 0) {\n      successMessage = `Housekeeping requests submitted! ${housekeepingSubmitted} requests sent to staff.`;\n      confirmationMessage = `Request #${orderId} - ${housekeepingSubmitted} housekeeping services requested`;\n    }\n    \n    components.ui.showNotification(successMessage, \"success\");\n    components.chat.addMessage(confirmationMessage, \"system\");\n    \n    return JSON.stringify({\n      success: true,\n      result: \"success\",\n      message: successMessage,\n      orderId: orderId,\n      orderSummary: orderSummary,\n      housekeepingSubmitted: housekeepingSubmitted,\n      chatMessagesSaved: chatMessages.length\n    });\n    \n  } catch (error) {\n    console.error(\"Tool::Script::\" + toolName + \" error:\", error);\n    \n    components.ui.showNotification(\n      \"Failed to submit order. Please try again.\",\n      \"error\"\n    );\n    \n    return JSON.stringify({\n      success: false,\n      error: error.message,\n      message: \"Failed to submit order. Please try again.\"\n    });\n  }\n}",
          "run_after_app_init": false,
          "order": 10
        },
        {
          "tool_name": "FinalizeSessionForNextCustomer",
          "description": "This tool will help you to clean the screen and leave it ready for the next customer. It should be used only after the order has been submitted. ",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"properties\": {},\n  \"required\": []\n}"
          },
          "script": "async function execute({...args}) {\n  const { components, toolName, utils } = args;\n  console.log(\"Tool::Script::\" + toolName + \" executed with args:\", args);\n  const endSessionMessage = \"Thank you for your order! Your request will be processed shortly\"\n  const startSessionMessage = \"Welcome, connecting with cachier...\"\n  components.app.stopUI(true, endSessionMessage, 10, () => {\n    components.app.startUI(startSessionMessage, false);\n  });\n  return JSON.stringify({ \n    result: \"success\",\n    message: \"Tool executed successfully\",\n    instructionsForCachierAgent: `You can now tell the customer: ${endSessionMessage}`\n  });\n}",
          "run_after_app_init": false,
          "order": 11
        },
        {
          "tool_name": "MenuValidation",
          "description": "This Tool validates if a requested item exists in the menu and returns the exact menu ID or suggests alternatives. Use this tool BEFORE calling AddToCart to ensure item availability.",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"description\": \"Validates menu item availability and returns exact menu ID or suggestions\",\n  \"properties\": {\n    \"requestedItem\": {\n      \"type\": \"string\",\n      \"description\": \"The item name or description that the customer requested (e.g., 'lemon milkshake', 'cheese burger', 'buffalo wings')\"\n    }\n  },\n  \"required\": [\n    \"requestedItem\"\n  ]\n}"
          },
          "script": "async function execute({...args}) {\n  const { input, components, toolName } = args;\n  console.log(\"Tool::Script::\"+toolName+\" executed with input:\", JSON.stringify(input, null, 2));\n  \n  try {\n    if (!input.requestedItem || input.requestedItem.trim() === '') {\n      return JSON.stringify({\n        success: false,\n        error: \"No item specified for validation\"\n      });\n    }\n\n    const requestedItem = input.requestedItem.toLowerCase().trim();\n    console.log(\"Tool::Script::\"+toolName+\" validating item:\", requestedItem);\n\n    // Get all available menu categories\n    const allCategories = components.menu.getAllCategories();\n    let allMenuItems = [];\n    \n    // Collect all menu items from all categories\n    allCategories.forEach(category => {\n      const categoryItems = components.menu.getMenuItems(category.id);\n      if (categoryItems && categoryItems.length > 0) {\n        allMenuItems = allMenuItems.concat(categoryItems);\n      }\n    });\n    \n    // Remove duplicates based on item ID\n    allMenuItems = allMenuItems.filter((item, index, self) => \n      index === self.findIndex(i => i.id === item.id)\n    );\n    \n    console.log(\"Tool::Script::\"+toolName+\" searching among\", allMenuItems.length, \"menu items\");\n    \n    // 1. EXACT NAME MATCH (case insensitive)\n    const exactMatch = allMenuItems.find(item => \n      item.name.toLowerCase() === requestedItem\n    );\n    \n    if (exactMatch) {\n      console.log(\"Tool::Script::\"+toolName+\" EXACT MATCH found:\", exactMatch.name);\n      return JSON.stringify({\n        success: true,\n        matchType: \"exact\",\n        validatedItem: {\n          id: exactMatch.id,\n          name: exactMatch.name,\n          price: exactMatch.price,\n          category: exactMatch.category,\n          available: exactMatch.available\n        },\n        message: `Found exact match: ${exactMatch.name}`,\n        instruction: `Use itemId: \"${exactMatch.id}\" for AddToCart`\n      });\n    }\n    \n    // 2. PARTIAL MATCHES (contains search term or word matches)\n    const partialMatches = allMenuItems.filter(item => {\n      const itemName = item.name.toLowerCase();\n      \n      // Direct substring match\n      if (itemName.includes(requestedItem) || requestedItem.includes(itemName)) {\n        return true;\n      }\n      \n      // Word-by-word matching\n      const requestedWords = requestedItem.split(/[\\s_-]+/).filter(word => word.length > 2);\n      const itemWords = itemName.split(/[\\s_-]+/).filter(word => word.length > 2);\n      \n      // Check if any requested word matches any item word\n      return requestedWords.some(reqWord => \n        itemWords.some(itemWord => \n          itemWord.includes(reqWord) || reqWord.includes(itemWord)\n        )\n      );\n    });\n    \n    if (partialMatches.length > 0) {\n      console.log(\"Tool::Script::\"+toolName+\" PARTIAL MATCHES found:\", partialMatches.length);\n      \n      // Sort by relevance (prioritize items that start with search term, then by length)\n      partialMatches.sort((a, b) => {\n        const aName = a.name.toLowerCase();\n        const bName = b.name.toLowerCase();\n        \n        // Prioritize items that start with the search term\n        const aStarts = aName.startsWith(requestedItem);\n        const bStarts = bName.startsWith(requestedItem);\n        if (aStarts && !bStarts) return -1;\n        if (!aStarts && bStarts) return 1;\n        \n        // Then prioritize items that contain the search term early\n        const aIndex = aName.indexOf(requestedItem);\n        const bIndex = bName.indexOf(requestedItem);\n        if (aIndex !== -1 && bIndex !== -1) {\n          if (aIndex !== bIndex) return aIndex - bIndex;\n        }\n        \n        // Finally by length (shorter = more relevant)\n        return aName.length - bName.length;\n      });\n      \n      return JSON.stringify({\n        success: false,\n        matchType: \"partial\",\n        error: `\"${input.requestedItem}\" is not available in our menu`,\n        suggestions: partialMatches.slice(0, 3).map(item => ({\n          id: item.id,\n          name: item.name,\n          price: item.price\n        })),\n        message: `Did you mean: ${partialMatches.slice(0, 3).map(item => item.name).join(', ')}?`,\n        instruction: \"Please confirm which item you'd like, then use the exact itemId for AddToCart\"\n      });\n    }\n    \n    // 3. CATEGORY-BASED SUGGESTIONS (Dynamic - no hardcoding)\n    // Extract potential category hints from the requested item\n    const requestedWords = requestedItem.split(/[\\s_-]+/).filter(word => word.length > 2);\n    let categoryMatches = [];\n    \n    // Check if any word in the request matches any category name\n    allCategories.forEach(category => {\n      const categoryName = category.name.toLowerCase();\n      const categoryDisplayName = category.displayName.toLowerCase();\n      \n      const matchesCategory = requestedWords.some(word => \n        categoryName.includes(word) || \n        categoryDisplayName.includes(word) ||\n        word.includes(categoryName) ||\n        word.includes(categoryDisplayName)\n      );\n      \n      if (matchesCategory) {\n        const categoryItems = allMenuItems.filter(item => \n          item.category && item.category.some(cat => \n            cat.toLowerCase() === category.name.toLowerCase() ||\n            cat.toLowerCase() === category.displayName.toLowerCase()\n          )\n        );\n        \n        if (categoryItems.length > 0) {\n          categoryMatches = categoryMatches.concat(categoryItems);\n        }\n      }\n    });\n    \n    // Remove duplicates from category matches\n    categoryMatches = categoryMatches.filter((item, index, self) => \n      index === self.findIndex(i => i.id === item.id)\n    );\n    \n    if (categoryMatches.length > 0) {\n      console.log(\"Tool::Script::\"+toolName+\" CATEGORY MATCHES found:\", categoryMatches.length);\n      return JSON.stringify({\n        success: false,\n        matchType: \"category\",\n        error: `\"${input.requestedItem}\" is not available in our menu`,\n        suggestions: categoryMatches.slice(0, 5).map(item => ({\n          id: item.id,\n          name: item.name,\n          price: item.price\n        })),\n        message: `We don't have \"${input.requestedItem}\", but here are some options that might interest you: ${categoryMatches.slice(0, 3).map(item => item.name).join(', ')}`,\n        instruction: \"Please choose from these options, then use the exact itemId for AddToCart\"\n      });\n    }\n    \n    // 4. NO MATCHES FOUND\n    console.log(\"Tool::Script::\"+toolName+\" NO MATCHES found for:\", requestedItem);\n    return JSON.stringify({\n      success: false,\n      matchType: \"none\",\n      error: `\"${input.requestedItem}\" is not available in our menu`,\n      message: \"Please choose from our available menu items or ask me to show you our menu categories\",\n      instruction: \"Use GetMenuItems to see all available options, then use exact itemId for AddToCart\",\n      availableCategories: allCategories.map(cat => cat.displayName)\n    });\n    \n  } catch (error) {\n    console.error(\"Tool::Script::\"+toolName+\" error:\", error);\n    return JSON.stringify({\n      success: false,\n      error: `Error validating menu item: ${error.message}`\n    });\n  }\n}",
          "run_after_app_init": false,
          "order": 12
        },
        {
          "tool_name": "ReplaceComboItem",
          "description": "Replace a specific item within an existing combo (e.g., replace cola with lemonade in burger combo)",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"description\": \"Replace a specific item within an existing combo with a different menu item\",\n  \"properties\": {\n    \"comboCartItemId\": {\n      \"type\": \"string\",\n      \"description\": \"Cart ID of the combo to modify\"\n    },\n    \"oldItemName\": {\n      \"type\": \"string\",\n      \"description\": \"Name of the item to replace (e.g., 'cola', 'fries')\"\n    },\n    \"newItemId\": {\n      \"type\": \"string\",\n      \"description\": \"Menu ID of the replacement item\"\n    }\n  },\n  \"required\": [\n    \"comboCartItemId\",\n    \"oldItemName\",\n    \"newItemId\"\n  ]\n}"
          },
          "script": "async function execute({...args}) {\n  const { input, components, toolName, utils } = args;\n  console.log(\"Tool::Script::\" + toolName + \" executed with input:\", JSON.stringify(input, null, 2));\n  \n  try {\n    // Get the combo from cart\n    const comboItem = components.cart.getCartItem(input.comboCartItemId);\n    if (!comboItem) {\n      return JSON.stringify({\n        success: false,\n        error: \"Combo not found in cart\"\n      });\n    }\n    \n    // Get replacement item from menu\n    const newItem = components.menu.getItemById(input.newItemId);\n    if (!newItem) {\n      return JSON.stringify({\n        success: false,\n        error: \"Replacement item not found in menu\"\n      });\n    }\n    \n    // Use existing comboItems if available, otherwise get from menu\n    let currentComboItems;\n    if (comboItem.comboItems && comboItem.comboItems.length > 0) {\n      // Use existing modified combo items\n      currentComboItems = [...comboItem.comboItems];\n      console.log(\"Tool::Script::\" + toolName + \" using existing combo items:\", currentComboItems);\n    } else {\n      // Get original combo definition from menu\n      const comboMenuData = components.menu.getItemById(comboItem.menuItemId);\n      if (!comboMenuData || !comboMenuData.items) {\n        return JSON.stringify({\n          success: false,\n          error: \"Combo structure not found in menu\"\n        });\n      }\n      \n      // Create initial combo items from menu data\n      currentComboItems = comboMenuData.items.map(item => ({\n        id: item.id,\n        name: item.name,\n        price: item.price,\n        isReplacement: false\n      }));\n      console.log(\"Tool::Script::\" + toolName + \" created initial combo items from menu:\", currentComboItems);\n    }\n    \n    // Find the item to replace in current combo items\n    const itemToReplaceIndex = currentComboItems.findIndex(item => \n      item.name.toLowerCase().includes(input.oldItemName.toLowerCase()) ||\n      input.oldItemName.toLowerCase().includes(item.name.toLowerCase()) ||\n      (item.originalName && item.originalName.toLowerCase().includes(input.oldItemName.toLowerCase()))\n    );\n    \n    if (itemToReplaceIndex === -1) {\n      return JSON.stringify({\n        success: false,\n        error: `Item \"${input.oldItemName}\" not found in ${comboItem.name}`,\n        availableItems: currentComboItems.map(item => item.name)\n      });\n    }\n    \n    const itemToReplace = currentComboItems[itemToReplaceIndex];\n    console.log(\"Tool::Script::\" + toolName + \" found item to replace:\", itemToReplace);\n    \n    // Calculate price difference (use original price if this was already a replacement)\n    const originalPrice = itemToReplace.originalPrice || itemToReplace.price;\n    const priceDifference = newItem.price - originalPrice;\n    \n    // Replace the item in the combo items array\n    currentComboItems[itemToReplaceIndex] = {\n      id: newItem.id,\n      name: newItem.name,\n      price: newItem.price,\n      isReplacement: true,\n      originalName: itemToReplace.originalName || itemToReplace.name,\n      originalPrice: originalPrice,\n      priceDifference: priceDifference\n    };\n    \n    console.log(\"Tool::Script::\" + toolName + \" updated combo items:\", currentComboItems);\n    \n    // Calculate total price difference from all modifications\n    const totalPriceDifference = currentComboItems.reduce((sum, item) => {\n      return sum + (item.priceDifference || 0);\n    }, 0);\n    \n    // Get original combo base price (without previous modifications)\n    const comboMenuData = components.menu.getItemById(comboItem.menuItemId);\n    const originalComboPrice = comboMenuData ? comboMenuData.price : comboItem.basePrice;\n    const newComboPrice = originalComboPrice + totalPriceDifference;\n    \n    console.log(\"Tool::Script::\" + toolName + \" price calculation:\", {\n      originalComboPrice,\n      totalPriceDifference,\n      newComboPrice\n    });\n    \n    // Update the combo item\n    const updatedCombo = {\n      ...comboItem,\n      basePrice: newComboPrice,\n      totalPrice: newComboPrice * comboItem.quantity,\n      comboItems: currentComboItems\n    };\n    \n    // Update the cart item\n    components.cart.updateCartItem(input.comboCartItemId, updatedCombo);\n    \n    // Show notification\n    const priceChangeText = priceDifference > 0 ? ` (+$${priceDifference.toFixed(2)})` : \n                           priceDifference < 0 ? ` (-$${Math.abs(priceDifference).toFixed(2)})` : '';\n    \n    components.ui.showNotification(\n      `Replaced ${itemToReplace.originalName || itemToReplace.name} with ${newItem.name}${priceChangeText}`,\n      \"success\"\n    );\n    \n    // Get updated cart summary\n    const cartSummary = components.cart.getOrderSummary();\n    \n    return JSON.stringify({\n      success: true,\n      message: `Successfully replaced ${itemToReplace.originalName || itemToReplace.name} with ${newItem.name}`,\n      comboItems: currentComboItems,\n      priceDifference: priceDifference,\n      totalPriceDifference: totalPriceDifference,\n      cartSummary: cartSummary\n    });\n    \n  } catch (error) {\n    console.error(\"Tool::Script::\" + toolName + \" error:\", error);\n    components.ui.showNotification(\"Failed to replace combo item\", \"error\");\n    return JSON.stringify({\n      success: false,\n      error: error.message\n    });\n  }\n}",
          "run_after_app_init": false,
          "order": 13
        },
        {
          "tool_name": "removeCustomizationFromCartItem",
          "description": "Remove specific customizations, add-ons, or extras from items already in the cart (like removing cheese, changing bread type, removing toppings). Use this tool when customers want to modify existing items by removing only part of the customization, not the entire item. For removing entire items from cart, use RemoveItemFromCart instead.",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"description\": \"Remove specific customizations from cart items using natural language description\",\n  \"properties\": {\n    \"customizationDescription\": {\n      \"type\": \"string\",\n      \"description\": \"Natural language description of customization to remove (e.g., 'extra cheese', 'no onions', 'whipped cream')\"\n    },\n    \"cartItemId\": {\n      \"type\": \"string\",\n      \"description\": \"Optional: specific cart item ID if customer specifies which item to modify\"\n    },\n    \"removeFromAllQuantities\": {\n      \"type\": \"boolean\",\n      \"description\": \"Optional: if item has quantity > 1, whether to remove customization from all quantities (true) or ask for clarification (false)\",\n      \"default\": false\n    }\n  },\n  \"required\": [\n    \"customizationDescription\"\n  ]\n}"
          },
          "script": "async function execute({...args}) {\n  const { input, components, toolName, auth, axios, globals, utils } = args;\n  console.log(\"Tool::Script::\" + toolName + \" executed with input:\", JSON.stringify(input, null, 2));\n  \n  try {\n    // Get current cart\n    const currentCart = components.cart.getOrderSummary();\n    \n    if (!currentCart.items || currentCart.items.length === 0) {\n      components.ui.showNotification(\"Your cart is empty\", \"info\");\n      return JSON.stringify({\n        success: false,\n        error: \"Cart is empty\",\n        cartSummary: currentCart\n      });\n    }\n    \n    const customizationDescription = input.customizationDescription.toLowerCase().trim();\n    console.log(\"Tool::Script::\" + toolName + \" looking for customization:\", customizationDescription);\n    \n    // Find items with matching customizations\n    const matchingItems = [];\n    \n    for (const cartItem of currentCart.items) {\n      if (cartItem.customizations && cartItem.customizations.length > 0) {\n        // Find matching customizations in this item\n        const matchingCustomizations = cartItem.customizations.filter(custom => {\n          const customName = custom.name.toLowerCase();\n          // Match by exact name or partial match\n          return customName.includes(customizationDescription) || \n                 customizationDescription.includes(customName);\n        });\n        \n        if (matchingCustomizations.length > 0) {\n          matchingItems.push({\n            cartItem: cartItem,\n            matchingCustomizations: matchingCustomizations\n          });\n        }\n      }\n    }\n    \n    console.log(\"Tool::Script::\" + toolName + \" found\", matchingItems.length, \"items with matching customizations\");\n    \n    // Handle different scenarios\n    if (matchingItems.length === 0) {\n      // Scenario 3: No items found with the customization\n      const availableCustomizations = currentCart.items\n        .flatMap(item => item.customizations || [])\n        .map(custom => custom.name)\n        .filter((name, index, arr) => arr.indexOf(name) === index); // Remove duplicates\n      \n      components.ui.showNotification(`Customization \"${input.customizationDescription}\" not found in cart`, \"warning\");\n      \n      return JSON.stringify({\n        success: false,\n        error: `\"${input.customizationDescription}\" customization not found in your cart`,\n        availableCustomizations: availableCustomizations,\n        message: availableCustomizations.length > 0 \n          ? `Available customizations to remove: ${availableCustomizations.join(', ')}`\n          : \"No customizations found in your cart\",\n        cartSummary: currentCart\n      });\n    }\n    \n    // If specific cartItemId provided, filter to that item only\n    if (input.cartItemId) {\n      const specificItem = matchingItems.find(match => match.cartItem.id === input.cartItemId);\n      if (!specificItem) {\n        return JSON.stringify({\n          success: false,\n          error: `Customization \"${input.customizationDescription}\" not found in specified cart item`,\n          cartSummary: currentCart\n        });\n      }\n      matchingItems.length = 0;\n      matchingItems.push(specificItem);\n    }\n    \n    if (matchingItems.length > 1) {\n      // Scenario 4: Multiple items found - ask for clarification\n      components.ui.showNotification(\"Multiple items found with that customization\", \"info\");\n      \n      return JSON.stringify({\n        success: false,\n        requiresClarification: true,\n        error: `Found \"${input.customizationDescription}\" in multiple items`,\n        matchingItems: matchingItems.map(match => ({\n          cartItemId: match.cartItem.id,\n          itemName: match.cartItem.name,\n          quantity: match.cartItem.quantity,\n          customizations: match.matchingCustomizations.map(c => c.name)\n        })),\n        message: `I found \"${input.customizationDescription}\" in ${matchingItems.length} items: ${matchingItems.map(m => m.cartItem.name).join(', ')}. Which item would you like me to remove it from?`,\n        cartSummary: currentCart\n      });\n    }\n    \n    // Single item found - proceed with removal\n    const targetMatch = matchingItems[0];\n    const cartItem = targetMatch.cartItem;\n    const customizationsToRemove = targetMatch.matchingCustomizations;\n    \n    console.log(\"Tool::Script::\" + toolName + \" removing from item:\", cartItem.name);\n    console.log(\"Tool::Script::\" + toolName + \" customizations to remove:\", customizationsToRemove);\n    \n    // Handle quantity > 1 scenario\n    if (cartItem.quantity > 1 && !input.removeFromAllQuantities) {\n      components.ui.showNotification(\"Item has multiple quantities\", \"info\");\n      \n      return JSON.stringify({\n        success: false,\n        requiresQuantityDecision: true,\n        cartItem: {\n          id: cartItem.id,\n          name: cartItem.name,\n          quantity: cartItem.quantity\n        },\n        customizationsToRemove: customizationsToRemove.map(c => c.name),\n        message: `You have ${cartItem.quantity}x ${cartItem.name}. Do you want to remove \"${input.customizationDescription}\" from all ${cartItem.quantity} items, or just some of them?`,\n        options: [\n          \"Remove from all quantities\",\n          \"Remove from specific quantity (will split into separate items)\"\n        ],\n        cartSummary: currentCart\n      });\n    }\n    \n    // Remove each matching customization\n    const removedCustomizations = [];\n    for (const customization of customizationsToRemove) {\n      console.log(\"Tool::Script::\" + toolName + \" removing customization:\", customization.name, \"from item:\", cartItem.id);\n      \n      // Use the exposed removeCustomizationFromCartItem function\n      components.cart.removeCustomizationFromCartItem(cartItem.id, customization.id);\n      removedCustomizations.push(customization.name);\n    }\n    \n    // Show success notification\n    const customizationText = removedCustomizations.join(', ');\n    components.ui.showNotification(\n      `Removed ${customizationText} from ${cartItem.name}`,\n      \"success\"\n    );\n    \n    // Get updated cart summary\n    const finalCartSummary = components.cart.getOrderSummary();\n    \n    // Sending cart item to the API for synchronization\n    const tokens = await auth.getTokens();\n    const payload = {\n      roomNumber: utils.storage.getData('guestRoomNumber'),\n      loyaltyId: input.loyaltyId || \"null\",\n      cartSummary: JSON.stringify(finalCartSummary).replace(/\"/g, '\\\\\"')\n    }\n    console.log(\"Tool::Script::\"+toolName+\" syncing with API:\", JSON.stringify(payload, null, 2));\n\n    // Fire-and-forget with error handling\n    if (tokens.idToken && globals.cartAPIURL) {\n      axios.post(globals.cartAPIURL, payload, {\n        headers: {\n          \"Authorization\": `${tokens.idToken}`,\n          \"Content-Type\": \"application/json\"\n        }\n      }).then(response => {\n        console.log(\"Tool::Script::\"+toolName+\" cart synced successfully:\", response.data);\n      }).catch(syncError => {\n        console.error(\"Tool::Script::\"+toolName+\" cart sync error:\", syncError);\n        console.error(\"Tool::Script::\"+toolName+\" error details:\", syncError.response?.data);\n        // Don't fail the whole operation if sync fails\n      });\n    } else {\n      console.log(\"Tool::Script::\"+toolName+\" missing tokens or cartAPIURL\");\n    }\n    \n    return JSON.stringify({\n      success: true,\n      message: `Successfully removed ${customizationText} from ${cartItem.name}`,\n      removedCustomizations: removedCustomizations,\n      fromItem: {\n        id: cartItem.id,\n        name: cartItem.name,\n        quantity: cartItem.quantity\n      },\n      cartSummary: finalCartSummary\n    });\n    \n  } catch (error) {\n    console.error(\"Tool::Script::\" + toolName + \" error:\", error);\n    components.ui.showNotification(\"Failed to remove customization\", \"error\");\n    return JSON.stringify({\n      success: false,\n      error: error.message\n    });\n  }\n}",
          "run_after_app_init": false,
          "order": 14
        }
      ],
      "globalParameters": [
        {
          "id": "param_1753890888050_menuapi",
          "key": "menuAPIURL",
          "value": "/menu",
          "description": "API endpoint for menu items",
          "order": 1
        },
        {
          "id": "param_1753891522025_cartapi",
          "key": "cartAPIURL",
          "value": "/cart",
          "description": "API endpoint for cart operations",
          "order": 2
        },
        {
          "id": "param_1753891782635_orderapi",
          "key": "orderAPIURL",
          "value": "/order",
          "description": "API endpoint for order submission",
          "order": 3
        },
        {
          "id": "param_1753891819063_loyaltyapi",
          "key": "loyaltyAPIURL",
          "value": "/loyalty",
          "description": "API endpoint for loyalty information",
          "order": 4
        },
        {
          "id": "param_1755756463752_roombookingapi",
          "key": "roomBookingAPIURL",
          "value": "/room-booking",
          "description": "API endpoint for room booking information",
          "order": 5
        },
        {
          "id": "param_1755875598550_7647r119i",
          "key": "chatAPIURL",
          "value": "/chat",
          "description": "",
          "order": 6
        },
        {
          "id": "param_1757139457386_vsa11kuux",
          "key": "housekeepingAPIURL",
          "value": "/housekeeping",
          "description": "API endpoint for room housekeeping order request",
          "order": 7
        }
      ],
      "companyName": "AI Room Service",
      "autoInitiateConversation": true,
      "initiationAudio": "data:audio/webm;base64,GkXfo59ChoEBQveBAULygQRC84EIQoKEd2VibUKHgQRChYECGFOAZwH/////////FUmpZpkq17GDD0JATYCGQ2hyb21lV0GGQ2hyb21lFlSua7+uvdeBAXPFhxxjdXxtG5WDgQKGhkFfT1BVU2Oik09wdXNIZWFkAQEAAIC7AAAAAADhjbWERzuAAJ+BAWJkgSAfQ7Z1Af/////////ngQCjQ8OBAACA+wN/k3sG5zIOetwbAAtVmci/DPRJMrouFZr8PnHDTfT5mSbEWzm5R2RBV79CYv4RrZjaQUQIdP+RbUTiEYBeBnc1pxRINAuoHJNtIcyO+7fVRM9IgSI9/QapzF15QWG3zgOwjLUCFy5oqFhyqnPBCUbVozLvJ2tTjzVlSi97nH7td92/RcpT3f5KNyZkIUoqbp6XgsjYpJbVnxOrM/Q8deUCKZart7mCrLEPm3kIo1rSnNfwrGTG0yeT3smV/wqCC9Dhkth8ze5TBb1NvOZ7sYhzeNyLxYisngcTE7YKHnUM+bvvuq0VVKnmtPEeRRD558chY7XKIySRSnYIJjvgCPz+RrLyqKA+Um9ckbXI+cfc4qkcVLBCdU2rcgE3mGjl6ME98VQgMgd6KTFukthBqkR2WsAc4+wfBw5pJjZ4Nx8Qx4vFy1voMDyLkDL+mdOkdSu4llCZNTV2Si2U2DBtwNzOzM93gdInnTwt5d9fDAT8vCtq14qFLw36+INoa1POekBrt6QrUxOYzANhk53XAwDG6MxwLIClMBrD8eWWRAP8+gPEQvDpn7NoWZJgGsQGKb/fTUc+SrFQ/WqQoQzn1dTqndqCUxXFs8h25RyFZLAjTjOprRCryTXvNmNK4w2rdFQU+luMruYzESl92djWluTz6AFdLGx6oRo2s4X5umAuKRV986aVxvTCBRzHAPUBWYpDNl0UukuMON3go2JV045OGCt0LISWRXpBReXYg/2jheyS9tpN9qgebSO6gG7gtr07wCh16nxdeVHsaaSGXW9nzCXkCmizcOYqpHbE9pm1CVHXHZgkHM4SOdA186uIZcG0KV/Jfe7kdZi2TIXgpm8T1nZ/u3u5Gx/TNBwqjT9K/cKn4O8SaJtsMkKqaBMafHCkfaQM/xHf7I+AGw0rgNsIB+MjI1750VbT88GJCXFz9OBPKMicYBIyLiame2HHAFsCXnDrSrce6QRIAojTzivdHZErm/HhC8koiaP8avW/fKfZrHyCSpB68x5e1v3bmPm2+UFbUmruumZTZw6frvWX6EKp8w+bNpbgS+hrbCIutePuaEBObNPHnUyH5w5D6oETLWBB245evLOwprITclSWbFelk0Xr6VNQN2l4LOuglecyNPP3J1/cEY8Vk25oIm5AzTvMLGf78DKKaPgyrZDyy27LWsIa6XO4uL43PXuW9FqnmPGZwPeTYo8/I5BDNfxBYYN5VmWRDWmhvfQHvfS9gHTiG6T7fFL4SLxPm6Fju4qoeSk+SPO3Pa3WltyjQ8OBADyA+wNRkoUzpmWaAnJUV5iR6N+xxMHNDdLFj4BFyrJZUE1yLSIvOOaBlxVhdKpqnT6a1xJIaUCY5lktDd79M8XFM2aqxZNZLo2vjQxWxaCW9UphHDt/PWDVWIMio12K1iFzzV5Q6ykU7WeqBYLOzT78oR7vN8N/wANCMxnIYGHPfQW25CxiNeNR3p2JjWGOybLCs+H5qPtZnhhpBV552MRqIIEcSLBho3tSB11kqQJnpOMt57GD3DxfSqzFN1KwhcdXD7aJN8pjETKiM+IHHKskmbhgKY7doH1/Ag61PH/LOTinIslflA2YKbSBdfT1UpvyfiqibcMyyWCL5lFgXZ4b7L/jCuMkYKFZUJUOrD4TNAbIQYAKlRIR4yd9xTnKVuiZ5dEi4fGz8Hzrxi7GRbeXMG1n4nrlabhnySmofVcofDJ+U64HIueleb0KMFOSPdyqQZaFkxw6spVlNLfX1kJQPw1l+ItcRvMsHhh3Yvah1oogdRSQ8HmvPEpW/o86cLR+3izh8fJme+zZRJYaxk9b+ehCy5hh5kIHEZ2WCiN0zb5Lj2MiD8p5ZxA2skI2J+luDbCvT8yzbr88yJfh7srsAHkYw78t00n2VX8WfLJKldpqjryX0vWmiWe8DYxMjrd871NCl4PWfJnGf4qcF7hRc6XKRi4VqG/uEAblgXNi/Rt8CUvf4QnHR9ExwI7M+sKfghc0oFbfp0aiPXo1PxBjL701o5Ee37kFCSfzzoVwY4klFBvaBetCDTAf2nPG1bpXxAUpNO8voYr4aD/uTrcaErwnLuzdwugnGOl4qg3i5pjapD8CPhclenWDfzkkYKUZxT9Nr0V4q7SjkJzAxvOLp1pB6iP3wZSVO1W+DGjFsboRgXv3xstU/4MlqTUHPSCCB+eB7nfcS5CbUTUhPthoNbc5JKNrn8gRavusvxh7oCmeF3tQ+ujkK5DNP9uw4Bi4CVLfpnV1Rn/gJ2fJIIsLeOih3HklgxmUHv1GxSiSUFBwIQ5WEo78/6OuYnjVdhGvNfFFciL23enf1Wx0WG5vIClOrpl7WWTCHS4rfEnFiJMolazuWRw1jxsu38CK6hkVp1LTboMsEClJuJwqOsXiexV3yfMs4ndpUQc+Jl22fAyS06CjLOgZ8kQ0t1EUqcpZKpAk/l/izkmsYn8PJsenzpsa4tX0FjglX4sHDTxqrYhKLfT+aX8rHbtOQbRy6s2NBwZ9H/J6p9OEDBCX9UW95HLoUl/L7HEOFUhHAgZQk85nYoMyalJYXs1xTgcMaAyjQ8OBAHiA+wN49VbY1tPunqmnE3EPiioK77v5yPkxFFyFN4/x/Mg3Z6yyszAvIAuihJryhXYPOX1OV+bnXo1RBeYEbBJLKsdVIyPIyzKqm4UX9UaftT+OA2nAAMW+IqqnVwO2cqcejkIhCGJS9AQulRPBS9yqyAbM9S0GzFQOv3Ip8wwfBG7A1klA5GHZ+20yg0HgR6DQ2WDas57CbWfwqY1SnKQ0/dxv5g/zqcUqQWICtfqY5rUfOGwqtDaeNA+wRG27QP3B6SZj0/opZphfPLUF438RIDf55ePd4vLLJVNvPLMn4QNW+5Pxl1IYqsSRbN2Nub1peNa8tZVsYmAEDu72UMuBHL7km2rqj4r56N9djIM+A47cpX3kDtzvsv+L1lVotsRQNs72hoYJaF5yp+Z8G4A0S0xKOEiuBYdzlW0i8UgwQxYCXkBFYKx83C8QS9rJJbRibKjSQpLwBp+pZZfi+6SCVYgLxK6Xe3Fid18s6k9FvQCJHAv5NAWDiWdlEXKKhf52bWQNcARNgDJRfgheOoACqdA9/dgeRLMw66EgwCnA8v3IgxcKdUnWAiKlcJ4Lv97hWjJnDCwbInvtGr6DpzmvBJOTjn4m9NcmuiuZIbORajRjOkTIqAPADV7xjASUjbFOkNxcqh7pgcfeihNzarbRmdc5qRbQU+UqG6tj4rmqKK5WclmEhZJNAXpgJ9D3k3OZuY3wxctlxL1nRCpu4hTSPsvpEbdNlnl2Aobe1CjL+G6UwC0zBaPekrDGODBt/ECl0n9aP27d/rNVGQ8rCT4W5K4pYo3e9MCGIeVyNWMv9HUQfA4llvJ0KTQ8f62qoi50kMDEf3pQYuO6ycMa0FhEslmXQuZX5epHkhmFJi7AUnUGZZNw0IR1AhWz33Qcuads2TR214UzIME4xGj39RywmNFI6hNbd71aWTfI10nerQg5fhlNLH0CGRy2b7CiYINYvYfOYOxoi0+QF5RfV8WKhQJuOTXKMYtwYaTjlCpRT6q0WwPFPuHo33TC8u6avSnNqNm7jr9MfFC5hEigkdWK1l1deyy8Ekol9Frt5PBytkMXBIBsJXtX6D7FNujxQGnB1n68A5zUg856HRi7wjT60AcqW3Q5WA1JZ1Il+ZHtSy8MBE7mFaMpo22dlVljLkVycHjp8ZfXpG8pCd8sQLDW6mn8W521wRYPTP8AHOnuclcYmE0dR94tWdLUdW6msSKvT7EsgNUTqIND/uOXJALl/ycTjScdFGkqFe8qBmi3lcuEPso+ZqmrgGvDPb2ZpemjQ8OBALSA+wNyXTleZjYql0DBwYSqWcqg44bUsNwbOd6rKVZVXGbzm+/QvceGEaix1dDABveokweIIQvSaL4eHdjdCzGimKQmXgtVLJCXttH0jdneVmR2DZt5ucS0DpzaJ/CgAjHvedyt/a6UXPSh4PDI03msj+W6sE7hIJSgyxgrFjdSR7V3BUcxZ4NTV4gb9bHedB0aw5yY9Q5tuqH6HD+qU+kyRGRDrYPs+WUfg5XUlzxdM8DpzIhgqEKbI14oNL/+3fv5LJ7ToZmrnAJf2wQtLYsy5R83KbBVmuZEm9s6IZbwFMPxZGmSitDffDbGW0rAYAMM7jWz11W1gF/HIpA4s+o+WSRwcbBqiaLvpg2G4jyCoOXgYoWZmc6Rx36DzVu5aICuFzcl3Ck06tN4BKAg5sQBTlCb7mZa6mXUBkkublY2+qY234wjYSQDtEutSQvB/9x1I9r7IVFwbvSW9lYmnDL2dPrsmbBL+bvTIHwCloiKhSRGHqPX9fjcvyi2MpyxISvKayqfA7AX+waLUEKgFk3GGTYD7XmSZkApl/MW1osX4UoziE9ZRFv0K5rAgh4m41GIFKa8sQIMuooNpTg7oKED79eIye6G9r5Qr1f28s2aCvOWb1X/hXQbdaBSv971ad3cBaKVtVd/i0SxuB+CH7ZNMhF6GgUptor2kUr911/wsIagWk/hIpsUCp7S3SZZstyH6BaDhDQ82tKi2Qh8GY9FnZ1Dh/E5ynFfk6GERt7ChULNS5gzoHhb9AQi5UPMVk9Rqg8HfhaZLZAIuR0sI3Z4JWZCCdLElg1YmwbOO5pMytQHZ/ygFNk+jWszJJFJpAF92GoOf64jpVx4r9ww5ZusF9+GCAi32ZWMwsQgBrsb6QlkpR+f6BiKeZ6HZraJNk6FQuMJ48taeLYpmhQp86vX1CksY4JgYDvoOAvdGJW/D46y95+Qzn+9Vvk8P6BA0KBMWVDe2vgTNZDKBTdBY88I160mX3jJD5YPGRY4kMAmoJoaA/bmX+QlR05wUOAnj8ochg1HYdx9agcvBpjo7+AF0sr7AeY1UhpnAZEp490SQQGbbtdndKGLyg2gBln2rx36OJCLI67v3n6SV+l4q75BHKtqYTS17vlUb5C6rbUVi2Mj6LYYBYwIkYYfOfrgkMYiZRfmtG74lW9cPO0XwTJs0zulVQv14KYD17UdN1NgIJv6D5dnMhr309GaLilNqhINiZT3VX0RGeNWOiu+WCo6It+7zHVZG7jT+92nyPb7OTmOgChNyQ2yeK3Uk2gDjCSjQ8OBAPCA+wPYF0/pDJX0Ch+bQtdSnBehV+rC0FAr2rEPEK16gQmRj48yPJLOtBe04gui5azDM8xidhkgjazpWuYy+2az0GCnbxZoAVMdj8fTTEz9o2DgG8pSah1psh4HueHZZj3SFP8hIOXTNCAxSHElakXBFBs0GjVGBqGdJckvMMDdLNkO+pWRNz7qCM6pcrYhwxb9rw+gMzUKkDKFNsSzKsGfFJdSVJFQ4oaDmr+pg77xmDSqWo9ODioKWUc/DSiS94CWx9/H6CX4lEcGEj0oM1LMTWJnImrIMMjXBpOuTEXZro7cz9qVaI9Fg1X/28V4GvAmHcxJDs1OnqWorpBA04ij8yh1v9SFysnPKDUmsTGVdbRsBFxCMdkbbWC+qzy/b+Mlme/wLUeEvtqMLDzbtuNBbT1qG9UA8HiuC1hVXoHUiCRA31kR73OzrFCljtTH0CeZaxoby1UAewXp+htmZ0B88CS0QBUGPaEmF+vmzOuGat73PTK0Pcx/Ict2J9kvxHkYxncxpnRf3pPMKkJYS4NJyETF6Aj227hhx9wwRsgFnVZvJht9rDXPL92+wwP6PXicj49DUI/IUnWAySaSGG1VArBkAkpe6o8GT4CczwJ2Ym2zI0LS7L+9BZC6bgKibJrKbB5V7BMy2g9yuUpBfTjY2NjOkjU0ozGQyc6qh/2f0toZ4A3iRDItu/XDONGX5Hmx9H4kG1rjUT6/z0kfs2v2a7AKTF8FeEtj6ZK5pcDip8STt18pJsL+W1UnzUNATf186OPHVBo5rCFkh9DrYamNAZ+GnXQaMS3fq/s25PEyzEubZ3dkLrUbBhldawDACwbS6FHrcOVv4Ji8r5cddnB9OtfsQakavbCqJ+42zwVc4BUnz0YxWzusunO1BxTtoKf+7vTu6ZJVP4bccHsjheqF5zVJPiYGp/jBTsgefaFpyL74LnSASLSn/WTkbHUZEQ4Lf53eLYBDILsHnva6vwePVLPlu4HluaRZtDiaS1+B/3EUKzOBlVFUG3iBNQ46CYLTmFRN7p750fdDkYZi+V5Fh5l7sovyLeUEpkuKKpiQ1yddoVtT8KG0K/SuBAP0KKfgVcfDJiwebQ+4CNSQ02VxIDbLeoyfjf4KvyUoidnYSSiF8tFdF6tRVb6Bz4Sa07ziSvh9Tga8ue9o17a4ISLDvvnXYD6xuqwWerduOetzBRpij0dlepBtc4rDIVkctwwkKBwahBgEC+8sJ+egHxLg/gAo2nYvebO+/oxMVb0DCQXs+BwolZ16Z6FvH48kTTajQ8OBASyA+wPVYeynslDxhY/2CJYCnYAPwMeH6UXqseCoDSM0E9/yHGfWoBPdz+HYOmaPgyXjB28JWO3qCD8k1U0GzA4JBF46LKgp9NQyEhgt5r2e6x763C6azFlrlmkI2qrKVGFsRA3xiDAH6QGEIQF/6l6Hk0/+82EOkY0rZj2adpuc+zCUwwNPfFcjcqTGn8fyQztbevAhU+960qdaI5fcYtVkjorJfQGsmGMFJn0zBtDJl1uwPCo1UTy9Ii8X6rrIhyXk/iM56pj/S9oXbEBGNsSkDCm9Yxwpmv5akpi7LP8LTwG1/TiwR/qCgz8NFt6NXgKzdK153hRG/nJKkgOmHU//niweeVWskLy64384ri4pDcRjAeLpTCwiFaqkKrhooQ6VPDqOnw7/XigRMTd4OFLdWOtUfH29TzAZWs4NGreg7uQ034atBapgdxDfJ/4DpfDSu9ZsS0ccvo82DolSnAngpbbd6pytlDw6laYsMqsUTh+0M559HwAi5LlMd7c+laeTcRFXoUiH3jjCoeuShQjwORDYnw1eiZ1vJD0XTn0641npKtfD0somhT+n5Ct2bsie1jTLhXOh7YBu2DjIQhjES4412Swb9U8OappGQ8vPXN4VFFyEP9Vc4/h922s8XIq0GmNrbll3BRh/yAFP62s/jBcfEqR0Z96HrsNW3UzrgFbcpZCZ4LuCqUgrVquS+COzF0wcskkAWCzfsEF36za95s8qWhnPYZPlbtnGmrz4a/xClvexKOqQrOOcx8pfNqhIhgjYPJPbD3aK0ZJoR4EKgYsPzb3JlprgtEb4i2LTfB9UCWH1NvVJ/FpK6C6uFnau/8qFe4ZBVr4Rglsm3q4ELa5mi7gNLiofE6ck38m98gmkAtdGensrbBuhTrRuofBOx7YeriRG23o9ddYMxoxzIoQxkSgrhhtjypmWb4g3N4qbXw6/Hv6spLwbzkAT2lc9v0Zv2v9WFYOIy+XuXxKEQ7y6Nr9XloTIsDUH5BoAUz8ds5H1gnXFHbYjp4KEyQzuE8xmfMV812OYVqQRKXjv/Jit/fBoGwme5M60PnvCFwgI2BZTAatGNVdgzWfpyJJrLPHvh3CLemXPkgmpGXloCcZzZlOXEu4qa5Ug45gL+jPTBUUwl/Ogro1H6xPrVpbSIwJsvBo0cZbxDvISFoaaJsFjyMD/yKk6dldzigx3ij1LtOUQyRks0yjC4KjKg6Ebq+Cu/PcPxTlEhU1SUDPjhi2c4qW1raTa8PYLM60qkbhXb3r9DHdlSt0vgJrBjSijQ8OBAWiA+wO29x/IShUf1rKdj62Qy3v44STd0B4p4rnk4jZqwYYLM/GYRacOCl1EGrcr3NVhQ0R63lNSd0OaA1zgf3j8srLlot0i/dSLdYe7jeWe5nAkZLIpluFrht0FPx6OT397LC3ro0/quXrnfr7raK2q32DGcRLTtwn4NtgWWOLMpGmDUaadJyOx5xM47kWfUvUGr3NTUYzf7Dan9JZKrVd1UyLVyJAsjcdeVkr0B67X6q9X0J9kOveWALplBXbH2/exLIa3TjEqnZIgsQ6yfRXq6XyaT3V0ZHmfMmb2rUytZG0EIjJzqccctt9x9G0lPQePtHwFaqDyDhNzOJ249YIF7BOzaWrBl1eKb2M3D86ytuV616mrVXRan90kpFmdf0tTJQfeDxjYkdHu/pPqjGvJy3PcLZ2ojQ68aNLAm48LOuMmuxqvLGpVtftNOdchBljRoK9xCl8yo82K8FeSRPtXi0CbA+KINIpj7JaIJi57b633lvVVbt9Ur64ojOhfFTeyjoc11/g0DlZvPbQZnOeUZl9F1gM07m5Q7+1SX3DbnmKXEu6kiJt5tf9b0F9mMfqRn0XcvzgWbDl3oOkxb0y6XnVVAJUrS0/yk5cunrDnsnA8NJT2F4PUl4XRG+PHnTOu2lWLnccZBmq4sq0UhCLjBMRWHodnjzajhaExDYlIwyYHcY7plNjHIr4hW7+xrOAp2x1RmHmw2V8L/nSNhz5vTR9ciMR/72cXWw90VzbmUvHfWmFDW1TCKeTqC6hYtEZFjrZtyqDENfdG7Imf3mpoh6hZxiDMx642FXJbMHUPzvhOyQYosyfDDKTZby3RIBKe0f2lEPvkzyz9IVQfRPD2qrsbYLm8H1SMZ4YskBynL8rqftBnhl7osNubEtphraOHSqE897n3g936VPQTfunaDATgfFM5PbpedfhArpZMHQucaNDklr2DuSsgIc5+f431uN3B+n2MdxrfgzYmZG4mctuucTn8p1N7ql+IyF9RH3+SkIG+ibBLysMUQ2w538Poe71KLZE1sQ2MIE89cEUGMSuq3xaSo6UnWa+DqVXK17qzFxlgQTwDo7j44/GMawdwztd7gTJU4+puZ7151i91dr/PEov+0HmeSWp9oTXmtWT6DrDW9HTXqDvZL76IIGB8iQqgrjrJYqr3vwnkG2daC5d62/ecgOw5HaqzvPOfipYtT7LE+a+FJyTF3g0TRNJEFoY8shv7t0vWUaT3m+ykSXMyHeN2nM+WGetxYF7j8w2Dk8wbSqMh0F0qdj9VIqqjQ8OBAaSA+wO8D8hBE4O3XTuJui2hh0Zfzm3X112fxK/qsXMwaHL72C39i/bVaGWkx0h/UdnJ5VejzTNFmDBLMyktHNv8NaJiEh1TFbNKenNr7pK3+Vy6tpMcKSp/ZOLSz2cTH9uOMC6hIppA0Cl99p3LdKp5bw9T+mJOzQQDvqVUtxrQejuxeswy1pHlvv+tLA2MwefIERjrIg60GqDxgPJl6LBLenV1Lwk8Da6HgBblIzkoYjVy/4Xqusu9rQqIchxDJbbBQb2NW3/e9oZbaoqh1dDFbu44bkhTNyms+ZEA0CYzv+HPBOFFIP4Xg4K/2PL1LKNc0+0SSJ1jBvLv6yphWnVRAHMF0IqdDKikp/5RZvWTZRQ0HqKXva6g3nbnY1kVBZhopAMhaqm94plWON309yyak0MYjd/0myhGawTTFPod7TsovCkKiql8vUlZzsDcnZgdan7SAhq0+PbIcUd97S2/3H4DZ30XRPky1RkG9798tF3GXmLVhPtCfXmPMufdjUXvF4s8GKTDBlW+f9ei0c/MQpBJlrpCHnpWycHCxoNomDFh4y6PCYz8yQ19Riqfk36sdPhqyI9Xocz33cRVebslA7JpM/C1immSZec07rUZq0xuzUPtyWGQcRPQDsPiOsyqX+5Vd5381ZwOs5KpZSS5ip6Xm04q7VNhgDQtATNp9IwTrlIHPS7C/pQsZKMay9B3PYjhBwzB2DZrlJIDVU9k6S/ku+ttBLhLez21u0ai1Pu+OBIOUhrXE9AWSrDGmCywbxgYx4oVz1ZcT7OlM8zsVKF6j/e6OQ2F2EdlEQBiYjIlvukQzUcLZspcF1V1hwtYA/i9FQznee/2neAk5TwvKL4jOnFlaF+88CxZDOWYSpvkC3tfQpjcM+t2r0QyQE/Ap6t/euapJQnd2LPApaysYso9xtGpHS7FGZnhCWVTFziaCF4eOYYDyhxnkgO55RsTcfMr7Ls/sqZ8u2xXm1uuHVo5bpNwW2TGfwGydNYN60PEt3vXsgoZakZAmVx6MugKXJS16PRC09TK/7DgD8hQUMSvH3mpNe6L0sfe5JjVnoh/3nvO98PmcPUCaLonQSl9Q1nFkxBrht6qPlgHRudhcGQFDDpGcya9QsXTR9SHj/g1GStV4swYo0vmKai/iRLIIrh1HTHAJzqnNIBc+7RhikKRxIX8N260PzyEUIqNoCR3v5JNcKpzuDjYjGipqpVQcikw58yRb4tiF3mxqC+r+eY/j3rzXboFUtxZj78Yh/qEDcc6Np4dnlhmNNzz6SijQ8OBAeCA+wO9d05lgHFPv+tG25E9whvlPDa2qNOsrZDIQI97o6CRZzZMWkSxsVpjWS2ddqmY9nVW3ENNkUeqSzEPVoa8XUdh+ZcCqS9M9XY3JuIU7sac6UD1mqC5HF6v4U9chOn5bZYiXX4nfOaKXg4CbjEXepxIzaXntZrMLnnjPVwsjGPZymHX1em/ww1dP5dOspoi/ki3BtXk/fKgXB88D6+AwPosXzbA1UCsKpOjkOAESNF6q9g+TPUo/hfwu8mMIuPVWw4BTodofj7SzkUyYET2skziY+N031hTVUBUaLgopGY8f2F77TaBRZOuE/EWobPmcvQfQVM1jgwIqWYzE3SqWq6MVMn+pjDOCon4RQ3kLQL278Dn5tsUzy7xFubamxGfrS7HZUnNOI+bqNu70+Vv/7peKwNO/eAMaPLQ9QH4RB8nvXYpMvcPDvZYW/WFmQwKQ7lzxx6LDV1xEvOUKsu9+1KBZbGPZNkuvQoEfZdx0l0LA1s/GMAjNubdsRcdXZs8Oq3ktO0I+WgWeQdnxglJnnTvmhkFT2jgRqiPSCFqnbOrCP1mt0vAypmm+srKlT6KBuZJups9JhR3dUOHxwrCD/1ff32Ma/w6H4KQGMlw01qKUc1LM+P1fAEg/+j1l+sFP5flJz7LGEl1ynlkj9gI7cXtr+2VuXUsRpHe9dhfumB4Pex0eu33Bhf3hujUOjibZb6CiieZxnGApkAz7SizjemM8aYg2Xvt/VsOuIzF73rMLDTn3dfDJ5Rp/Cn/JeADA8EObxAW0byfm02u+jh+5MXdiOWhmN4cimzo7sumcSXURMrJsS96EyiQoapSP/GaRhHT0gcWVpNDY78XPkp5KL4pU4URSw9afmAxzFjfkEzVT6M0GwnH7PM278QeWItHZIlOqd9oHiv4PvBtkcQvhnd8OTBFJp0v8OK7HbEsAThWQEo69zVN48RQhyHW+Hivk4ql7K2QBB2L+dFQ5Irr7ZSXENclRju9EKF5FZ1Wl5kTH513DceXwXSu4U4d9ijoFVdOf3eRyHDxxosV5UBrpfAkAUw8ATUvpoKdzsl+vPvSI7RlXmwPFDutyRZ2d9MgcaNRK15rZAzHOzoCoMnQXVsSisMaI0/szI7SJqkxolPr+G3MoqZ+fk0kBYjW3oZSEiLfdA0RpJj3LN7uYrtUS+FGFp6Y7XWLQ9KTCJs9e6mq9TQqpdTUFbqfoFdutINtIUZLF+W3ntrSvT1CGbwGgvntbLjePCHkA1RTTPGdKCixJkE+jpOXyrELxeHeeyijQ8OBAhyA+wO4zxtAF67K/EmncqGWGcEOl/Vl2EvBxvXfqOEfKSkt04wU5FjrHAomKIHIx5zRu1K5SOHiWRAFOXUt+63E90/5zY1orSbIRTF73A2H1rKT8JsubLbi035q7FpsQ+9WJtBLbzWrVarK0uN/tiGzKYbg8DaOgUz28hEwm8nQAJLhthOOcKXiEdXDmOYXqHbhOlAkI7zTqK3iXgzTQuiphRJHjgH4IoqbJCLorCaZcaViAA4wpC4WB8Rdj3Erkg0aWNOyCoRWd+glggAvPPqij/P9sQL4Ikb3b3eHd5jLQboMoPO2S11q44GSEuZnPo+rso3PJxkPXtMG9hyTxnO9zcAAs77R8xWJFMM+qvGvwC5u1kwBetPiAdPYrWvrdbxDuzXQhMY8UQEJgTY+FSTxDp3TwF+SQXdNWBA2xyirNZaosCW+M+G1a9CDYtiYElqotBHEmLK9iWX8WbBhUb0vrwv5I4P2xbo/Wi19i7iAZHA5MWnuJXPpJHQQ4VTLdsvIfAfRNWd/CCWNDQlgxzWbp0oxRlp/e7c2fPEsdU2w2+EcR/+6B3bD0Pu12cfIQ6+cCGMNhoXGJ0Xcm2AA5JKwd0nFYN4Kh6GtnHM86cMKMNGMLYi6JhEZOoNTIBx9ZM3jK5q6w9qxRAbZeNl8yggoWFbiAN8n4Zo2cqxbuLoHPOniM5GV0W47bPkEF2eEznmnpiqB01DYC8R1GfZ3VKOsyamPBiQ68A8R31J1jB0JxjquL4Yo9VXCaDWkbiEaTQlPT29ouHdW9IWp7LywypAmVT7wP+0sjnBmvnkLrE3IGPWd0+izYZD5hxbxn5Lb8znmqB4uuFdb2SBpwqntOuc4qLJJZ8rLTTjSNqz1X3MvKbvs7QH6b9MM1i+gZtZXdzq71t6vUwGHO28La/ZjKS+o8JG6cAkhTDKtyQWHuuFN1mAltdvkdHP9YkZu5YZ0KQkrFtPtjV1rAKDjwcKApI0vQ+jHw4JlkbUk2coxy2wp5+MEpZLPvERB1MZe7q1uVdZvETdJKw+ioJFYiJobNB9migeVudF3aO1q1AfIUoPaFL8EiLSX3QDkQdnBlKYUu8fgm7zLoU4e5PEvRIs7cqjn9ztTlt7ZHEoQRLPCWttpNYhF8OCkL2Bmoi2ab5f0Q0bWwaD5wuK+v5Ntd7DVo2pI5yLFuwFIEPPY5iZ9yXnSgQ9yIn4rRTGlgVwwekUlMcudHkSMgwhi88wM3PrEZ/XkiRJyNGR4dBqUwLyWuklulPamMTDniB1IT4IxYJfgWyijQ8OBAliA+wOs/kYqtA/3GBNo8paGLE7iR5NMDKVdAbv3MH5yhod9eYPfKN9Xp9v2ZgYjpxaBuJC9cCAGI2JESYNC24uleEmu3hyRLWqfXynHILr7iBNlsK1VrMu1hmc3VN6GWJPt6j2m2U9TfruaXTKUi9Qc6SXrq/GUUcAFSz1ZWDAXOzugj+QHE+x3biObl2R7hrLlHie6TAXkdkDglsHFL5yRF0k2Z+KYaq8cXK1KHw9toQrC/35yArZm0w5Z72wdl815T3ZEY3DlxDRytKe5wUIx18JEohWO3U1awcoWqrDVe6eOPt5cefYNjZpDDfuciVwYrGZGGn4Y+reTLa2wK7JXMybIs2YlBuSCUI0NBGRa71vmnEpj+Z2bm7V9dDIab/YRO5M/kA8QmnY81ysLjmuEyBgb7enRVha3q5Pfu5PVi+GnsY6jUv4i7dKmC8ldzAC1bKBoQJ+9/ayba5RYtiyq0Bhi13lq56EJKYwyWpCWhgDlopt0W/YtPeqcUQwvsOARAywYr5gmMhVWKXvgmz7s19zYVypx1eiB0D5r3kMfk8e2QcS8IBYeW7ldPx39qzI6kMU0Oax9GvyJf03g2d8UhXunOnrOT9opXwI8BIkVv+cl0Me/dw0jlDi7ke6I54/U6ga8pJjaIW8jk6J2CxUw1zY20fsqtA+yM0w+tLLDpoYgPlyBpQG+0XmmGDciEx1zky8UUpl1mEBH5BcRE5otkexUzdFprF6Ec4HPvrX0QMXnyt0Si1QRJLgLAizmgTS2TNhf/azUBWleDUvKrKOq0leG4EkCk2XfXOczTxQ1PvqS3fojJ/9BkzUMaS/WVbXWXDe/zaGVNpCeoFltL9Lfp7KzTrj0WywRUWn56e2rL9PFj8MSr77XTWMp45mEN762bxKLjEcT2aKAcVSR11q4vcxH8O3O2v7ijl/cPbRGb4h2fUrURqvX5ksySCJYhsexzkdNmPmmJylK9yj7ANle47fIu5ONSSy+TRfgCBpX+WoOu7xs0z6L5MHl/5nRNMU0lJvXQjpgM9b0ZJbauH4py5SwUvE22hgxTtKt8sdUQylUXd9ufBbQsd3iIjWIhdLusj5+qjEmdErfja1E3ehAnBttl+skAsy5Ohjz6iEZXNRwDO4nU2bmrguHfCQ9u8E+Dh2QJRlCmwUUuEwU55Asni9i3Lj6D79Mw4IVaAvgc1VrKFzETFiNfbbZP6hu0pSyDO0M3HMkMGrPOrSuWfvAnXCpERRoN/GaTYzmzVP1AG86/4ndpZWzm/Vfc0pHfOijQ8OBApSA+wOv+4RUgt3Uo2JplL5gZR7yJ9lf3FtvxzyVvv/ABmwLTpkFBiqyAzV3XsJKMIB08YnHVqU/YvHLCvS46WarFN684qAC4mvKdH5GvfF9olVWOLo+Gdpqfw1rz0yq4JeEEm9umCTeORhrpCJ8gcgCDtgk1zTWkGQwDy4ip0IIBOWGnRasEv0fhQaz7LtKYrvyYHfyT6dG4o+qSsI7lWXew7/ZThG0ZpO3Tvm2/n8auu8OciZ/JNQjL/K4JfdnI+WqquD6ljAkptgS9vumvbZWx3KtEpmfrW61HhyCNdgWLYT3rxZbEeex56xkRJsxUL3AZERd9ko1yyIDumqBODJ461iTmy9N+o+190w2AqAutifS7wWLPp6siSV87IigtdLRiCM86n/H545t1f/8nIaN6tPBChs+eo/Rjv13OrtC/oDkWd8PzhKIZkTFPvp2XMzNcpjyyjw/+qD/4YV3Q0ZUUspuZ0S8cM1RCd4UxQPFJHtegig0cxvYn9h1jbsFqdew2Vjjyh/xqYzWUBDdqOOtBhKH1Gn1sMbmqd0EayfukaqeqPM5D13SnAIHDjMIh5cuX++zLx8c6/LLkxuUNzhWJXjHIRW8u0hFjBKgGGoJg7fGIb8jE+AIzmZ1u2DM4yVS3EkW2jXtoNmtAGV9ct0IBi4hKnM13nRyOOCM37d6XWjCgePfAhdqXuSPwTDh4iUH4nRdEIpXeY62CzhaWnYfwlDvK8GEseJrAMx0lBxZg7CbNzFqxEwpv6pqyDbo/ZJxr8hMDJWDrJYU2X0AOo/cEmPwATfBzaflPk7Shh9MUFbIFHOZy7aSAzeaN556YwuAFqI1hMGOL7lXwW89yAgVy7FpYsyABD4XymbjY0+cTrLUvj/m3W8QETnJs36Rh2lbNf3Z5vVPDZv4+PM5yI/zbUB/tAipQok4qNlE0IfWDaUbJm3eGLQVBRbb8QcXnEJcuuWMUq9Kir77z+KOZbxCs9Q3MnxI6F7xwWiSgIuvV1kdRMYg3tGWK2f9dDwp7UvyinaaF2dK5ah3F7t5wFr/yucAi1iRS5pAfBmqkI+QxiFAiHdVxQqSOhi3Iowo8bHP3RzGUDTvIG8ssIjIbx8mmiRTp1derQp+Z2ZMs8NeiPlXD02n7Idy7Jmtvu7yrbMF2jEfK4fn+qk29wn21BEOBzlcGOxGVTJHo4dgi7m13ihjF5000ncn2QQt/dF5MuR8ITbpOViM8fWoALn+yCbVNWIY3XrUkC3W7YTWoSU7FFzYPcl4W22cG2Dc4hiPYR2jQ8OBAtCA+wOyJt1p7E1d5TpfaG8D3lehbwOPuVLn7nuoBCAiNGO5wEqX4W4WlBm6jNKEH7D6FNJIwYbJKCgoCnmKr88aRbvG4O1Nbausd6NytLSpqsYGnXjh08RlKu+RdHnJRkJTi4q5Au4tYH+omCfKFj9e1egzYuwkJPgI6Oz+/FKDM+QgY4XFPpbVfka2i/PIjxUXDZV6bgzfalvxTUP1zmF1HJBmWu7K+69RDdKq8uJzBRDdHiBbkgM2mSatdhrw52aak1wHJR47+Q52bVnVvUAUdAAoh6Olr8WYFqaOVTipxoaLyTx4lmlLtu4P/Dc3h52KG/6wV2h6B6dYSWR8UTQUBO2/VX/AA23+8QrFcTLWVBDUU/DNZvaWPoODZ8TqJzpCWmq0AyiNgVF86+hgU7YHmaKaidWWfH/FgwVoejL0YwrosigwD0ABUjZBwoCc5BT6QN8NmqhuszsFxw5nDL/y5YBDRu2pesiV+/gM2ki+93lFqBZZXdCB/ZwWjvLczWbx8GY++nbud65F4jZiy1goJ8Em1Yrn2e+tmo7Fh42sX2ztaGSKXhguMXd3ewYY61/AGIAnqv0Jl6CV7piFgOwDOERTwVCT0dCDjo5sLa3FrGLanZI4GY69oCbZzg6sNQV69qHNhiRKN+Ev42nZDy+O0ZR/PqptypSP4GUBFZtWyJxmOzsa1kLrP33VXPWInN8gTqY4r3jvao7pURQDJHC2ckEUc5OX1G6JnBR2e2utFwlnvx9nXcZWTs+511hJm/Lx0mtuGzFK5YcZF+sk9OSupvBoIVn9H5fxoC3jtv1thsnF6RORyj/rCwNMT8wrp4Hk3nWB0cZh86AOUxrSJ4yS6rS0txJ2IKLgRA6VRK5910HSidsz2v8VQL3hgP+ZUe/75dLCBMVEe6uAfMswXyQDtTVHKYUeH1s8pIigyLh5zKxuGQy5FeXDkXCW8zfEYnxe1rWxfge7e1xfk5OT0CeprPMwhZojd5CE4FnMjZ0trg7oGy9/FvoA7wLEXd/iSoQ0bq5vjHgZBVyFQomBkGiu09F33+HAFNRrmJTCq8nLMiMJXDLkfxRD7KPHdzdrbEVCdgCqqlDiLmn6UgILkag+eVDbxOpj7y/NM75gYAq1yE0IUKBC7k84QiRg4YtLFaHmx3kyCO+vhYE5Mi4f+0VyBe7D9pgzzZuXdcH2exKsVqRC9ggS11rBtcVuvxRTNoLx3ArO4fUd3W94RMyUfZfS9VTIQAEEQRBq4+zmCqxuyZdZ30FcA7oYYmlBcuSLumqjQ8OBAwyA+wN46ErVw+IAbTQfiT4snUn52coHXDXr8D6Tpz2fgMNxwhlHeg+LPwW9ZVi1IL4MpJ2T5nbCkE1UwrD+L1Nfh1wgJaFfW1YBOjTFZfbk8xQq6MnhTbL30M80itu3LHhJhIqULMMqkyItC6K6fVD7NoqXhqmqBnyokj65CV4zHlv8XaEEqwTCO4TyQmltb+r5wVeF4XqjAAPrlS8pscDqMD/DOr+Do7atq54bBhOGCOBpWPkrydq9YEzhlUGvFOzeUXOjitm/EyeAFHVBISU7EY4Gv1HOROT+6uz4bXMxaEDvlRmONSQyQ0IWwhvsmaypT2Xo6lpnSnnFU41TMyt7QeaBaI4YHBm/j7ZlyTVoPXt+iws5gh5zZjDA9+OaOmhpaqTvXd9jjDCFM/bo8GGGcSF9e2nb6zFsRO73ow95cAyrU9jITLL+twHEo27vDrrT2SYMt+ag0YFZYsGFxFMlpJCJGtLx5zPCqCThwN07wbd7Tx4kdPQofb/16qgKnD1fH2r3bi7CHMiHX4wlvtJBrdCLnKz7IF3chh01SUA/Et1EMUI0rTRFS8jclBzNRGUa6PypTjg9igKMURV53Ypf18emLN/dYwAGnOXRcD/1aqBfYj5l1tAyNh2fxv9D4TK8bVZblVqN2H1fRKT9exSF3vP6WaQ936/Jqts3cZDyC/rrYfBmJb3jjVnnkK4PSz1OaGThbyceFaR9UCkvDwvH3LjPXyKhv1k8jJForASNFQyBAPh5nf87VzeHhQK4X/+3tM3dy8P1Adk2eGUXvU63u8VCSLjjK8lYnNag/V8hAWcLQJiiop2mFKWx7DtLROcw6Wi4YwT/bE8rNh6RTGPHqlKHxg5s0/fum/B4E/YWb9ttYh2Gujbok+adql8igmi3l8/ml5hjh1/Xro2Z6OsgjCH5iTDnxhQD7kfCftV9IyzGKmSTwMjY6Slo2aR1jmCh4siebp1gHsQZThcU9kU847MobnQPiFa5nyOK4P8mGxk6g5rfiQXKvmIvtl5ZG8jlMAqzf7aRkYaeQk+4OaBrYPlBKv0Rf5CA73JBHYHpbRWjJISIqZalHOI5JYvs16QogWSO40qoYJxT3tku6GaIcswqKhV0yZKk4WNGNVcpXjfUZSV6m2ZbGQ5NTuuXjGe93gar3H9Geif8xvO4magBxU1abIXwcfMT9D/pY5tlANlOnFUY+3ANEiSjKgr/Sls1cwLI0v/US3EUbpgcLfTHL4Y4Ty412/faVS1c0u8a8QA1mjIb3DaZ2wB1sxKKGLGjQ8OBA0iA+wNQVcz6udLLCl3RJSX3lrC0BpN+AdC/hp1NdGOFlQR3rFbYq2lbbuDHZLDvip3BKpa7TjcYEZVsEldbDwL4ApTaMsPixXNSzs+RLk6eCYjrVf7mvsCFuEZxl+kyRrc508j2jQmp9lY3Jsh9IW1DdkmlIuzZ4OqhX+uv3jgYJdGo/DI1bgrBcc87TbTcGgaVFW+or3C7gGYunOP9xs+ot7UKd5VGxj2qDPzRu2YpV7hzrDl6v0EKrOV1df3RGbCrMBu3gBQxPoSEI2PM5ekxN7pOQ4XA5Igtd0Oy+Sp8fCoYoJR2IFblIPZ7c5L25S0D6UhziaT3zomse8m/Lutkvc0gN1dn7pUxgdJJqq1CdkTAVUOW764+wPM5q9oDjbMaYmo1SrLSyihRiH4radO7+voeIFhkgNcKM5w7zzTX7j5CUbdFkCgyVaO5a3Nq7tvl/lWMwtzohfXq9aT5KeqDqnFoAn2tZp1JnU7lLbYXUaFKtg0JbcDVgrdElUrgJ9zHYbG2Yt96FdRUtPQf8cn0DTR2nz5KANR2YVll7VJubp7BD2a19yqG/Xc5KjAJlN0f11xUvWoKyFR/GBAt6c9zyeQo0CyAAdFLNo7Po7b3aQyRivPuhAjNT18woEmSaaIbksrAV+CL9A67Q8sY5e5r2tAaIzZmlpmJ3DGTlSC8byuPcnh4HXS4TFijc3pHtiZfDkXzM5X+ylPTwE4m6A6d05KQsPCRNtl5JV3mBTJ4BgBGOK1drAEO+6v9GddwBKQn7p+qjcKtZ3nDQzdEpOGuigc4SZ403uYp7/YmsvR2DR+oBet8xGSpOuvyrvdLVW7O+W2w9SAFIha9J0ZX+PtHiV4ERQIGUVhCLEu69Yf0qTg6OoN4vqMY8+hE9rIBeA3E9CSIKyQ9JqisxP43PGPQpEOqGbk+6nGdkCX3OkI+872LsQX4a0he6KuLknNjb0LXnLpZBN5Hor3Gymx+BO1+VJOwnfAb4HSvms06ZouC1jRQTeSTAAKVfy2oRBhv4FsjPSIfMJ+ZG8WXyqeiNJpD6BMfZTt/OsoOe/owEh2WoChByDP6MfGfKklPshF6ns7685wO/yNa5FSO2nlGTUxWaGvn30c+hb/vJK4VYprer6IPkILrBPudp9pZPGYuE3I7zGfTHe8iuxx0QDebZ/HNlsECMIifmAC0Moonef8Mupv73v3O2T85d4xfsMLcuf0UZfuJmxQ7LIVm/SkcOE93foVPe37uqyGgu47eHdzs8gcGNuWxotyr8iBgGOKoJt8="
    }
  }
}