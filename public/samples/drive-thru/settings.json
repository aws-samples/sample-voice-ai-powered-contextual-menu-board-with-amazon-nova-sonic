{
  "exportVersion": "1.0",
  "exportDate": "2025-09-17T15:34:11.366Z",
  "appVersion": "1.0.0",
  "settings": {
    "cognito": {
      "userPoolId": "",
      "userPoolClientId": "",
      "identityPoolId": "",
      "region": "us-east-1"
    },
    "agent": {
      "system_prompt": "You are a cashier at a Drive-Thru. Your goal is to take orders from customer sitting on their cars using short phrases to finalize the order. Never calculate the total by yourself. \n\nSteps suggested to successfully take an order:\nStep 0. Ask if the customer is a loyalty program member and request their phone number. If provided, look it up. Proceed as a member if found. If not found, inform them they're not a member but can sign up at the window. If the customer declines to provide a number, proceed without it.\nStep 1. No mater what, you will always give a warm welcome and ask the customer to ask you what they wouid like to order. \nStep 2. Listen and kindly acknowledge what you have listen from the customer before using any tool, that will buy you time to properly use them.\nStep 3. Get the entire menu using the GetMenuItems for you to get the full list of available products.\nStep 4. Breakdown the request from the customer and execute the appropriated tool.\nStep 5. Upsell side items from the menu if they are not in the cart yet\nStep 6. If the customer doesn't want to add any more items or customizations. Then repeat the order in the cart and ask the customer to confirm that the order looks correct before moving on to the next step.\nStep 7. Wait the response from SubmitOrder and do what the tool ask you to do.\nStep 8. ONLY after succeed on Step 7, you can use FinalizeSessionForNextCustomer.\n\nPRO TIPS:  \n1. Read the cart and confirm the items with the customer, also ask if there is any customization that they want to add to any of those items.\n2. FOR BEST USER EXPERIENCE proactively use ShowCategoryItems along the interaction, don't wait for the customer to ask you to show them the items in a specific category. ALSO If the customer is interested in a specific category, use it right away.\n3. CRITICAL RULE - Never provide the total by yourself, Always use the GetCurrentCartItems to get the total\n4. Always use the GetMenuItems tool to see if an item is available, don't guess or generate answer your self\n5. Don't use technical words or direct response and errors you receive from the tools, your vocabulary with the customer should be limited to the food available in the menu, no other topics can be discussed. \n6. For removals, use customer's exact words and let the tool ask for clarification when multiple items match.\n7. When removing items, use the customer's exact words in itemDescription (e.g., \"burger\" not \"Classic Burger\").\n8. You can only use approved product names, those are in the menu. Never use the ones provided by the customer, if they ask for a product that doesn't match with the menu, pick the nearest one and ask them to confirm.\n\nIMPORTANT SAVING INFO:\nCRITICAL: When AddToCart returns comboApplied.message, announce it exactly to the customer.",
      "tools": [
        {
          "tool_name": "GetDateAndTime",
          "description": "This tool will return the date and time for agent awareness",
          "inputSchema": {
            "json": "{\n    \"type\": \"object\",\n    \"properties\": {},\n    \"required\": []\n}"
          },
          "script": "// Your JavaScript code here\nasync function execute({...args}) {\n  const { input, sessionId, toolName, ...components} = args;\n  console.log(\"Tool::Script::\"+toolName+\" executed with args:\", args);\n\n  // Using America/Chicago for UTC-6 (Central Time)\n  const date = new Date().toLocaleString(\"en-US\", { timeZone: \"America/Chicago\" });\n  const ctDate = new Date(date);\n  return JSON.stringify({ date: ctDate.toISOString() });\n}",
          "run_after_app_init": false,
          "order": 1
        },
        {
          "tool_name": "GetCustomerLoyaltyInfo",
          "description": "This tool will return the customer loyalty information",
          "inputSchema": {
            "json": "{\n    \"type\": \"object\",\n    \"properties\": {\n        \"phone\": {\n            \"type\": \"string\",\n            \"description\": \"This is the phone number that needs to be asked to the user to get the loyalty information\"\n        }\n    },\n    \"required\": [\"phone\"]\n}"
          },
          "script": "async function execute({...args}) {\n  const { input, toolName, auth, axios, globals} = args;\n  console.log(\"Tool::Script::\"+ toolName +\" with input:\", input);\n\n  if(!input.phone) {\n    return JSON.stringify({\n      success: false,\n      message: \"The phone number is required to use this tool\"\n    })\n  }\n\n  let response = {};\n  try{\n   const tokens = await auth.getTokens();\n    if (!tokens.idToken) {\n      console.error(\"Tool::Script::\"+ toolName + \" auth: \", \"No access token available\")\n      throw new Error(\"There is an issue with the loyalty system, proceed without it\");\n    }\n    response = await axios.get(globals.loyaltyAPIURL+`?phone=${input.phone}`, {\n      headers: {\n        \"Authorization\": `${tokens.idToken}`,\n        \"Content-Type\": \"application/json\"\n      }\n    });   \n    \n    if(response.data.found){\n      return JSON.stringify({ \n        result: \"success\",\n        userInfo: {\n          name: response.data.customer.name,\n          email: response.data.customer.email,\n          points: response.data.customer.loyaltyPoints\n        }\n      });\n    }else{\n      throw new Error(\"There was no loyalty information associated with the phone number provided\");  \n    }\n  }catch(e){\n    return JSON.stringify({\n      result: \"error\",\n      error_message: e.message\n    })\n  }\n\n}",
          "run_after_app_init": false,
          "order": 2
        },
        {
          "tool_name": "GetMenuItems",
          "description": "This tool will pull all the menu items with all their attributes, it will also contain the item id that you can use in the cart",
          "inputSchema": {
            "json": "{\n    \"type\": \"object\",\n    \"properties\": {},\n    \"required\": []\n}"
          },
          "script": "async function execute({...args}) {\n  const { agentTriggered, axios, components, auth, toolName, globals, utils } = args;\n  //console.log(\"Tool::Script::\"+ toolName +\" with input:\", args);\n  \n  try {\n    // Show loading notification\n    components.ui.showNotification(\"Retriving menu...\", \"info\");\n    // Get Cognito access token for API Gateway authentication\n    const tokens = await auth.getTokens();\n    if (!tokens.idToken) {\n      throw new Error(\"No access token available\");\n    }\n\n    console.log(\"Tool::Script::\"+ toolName +\" idToken:\", tokens.idToken);\n\n    // Make authenticated API call to your API Gateway\n    const menu = utils.storage.getData('cachedMenu');\n    var response = {};\n    if(!menu){\n      response = await axios.get(globals.menuAPIURL, {\n        headers: {\n          \"Authorization\": `${tokens.idToken}`,\n          \"Content-Type\": \"application/json\"\n        }\n      });\n      utils.storage.setData('cachedMenu', JSON.stringify(response), 2);\n      console.log(\"Tool::Script::\"+ toolName +\" storing menu in cache\");\n    }else{\n      console.log(\"Tool::Script::\"+ toolName +\" get menu from cache\");\n      response = JSON.parse(menu);\n    }\n    \n    \n    var items = [];\n    if(response.data.items.length){\n      items = [...new Set(response.data.items.map((item) => {\n        return {\n          ...item,\n          available: true,\n        }\n      }))]\n    }\n    \n    // Avoid reloading elements in the view\n    // Only if is not triggered by the agent, the menu will be cleared out\n    if(!agentTriggered){\n      // Clear existing menu and add sample items\n      components.menu.clearMenu();\n      components.menu.addItems(items);\n      components.menu.setActiveCategory(\"All Items\")\n      \n      // Show success notification\n      components.ui.showNotification(\n        `Loaded ${items.length} menu items successfully!`, \n        \"success\"\n      );\n    }else{\n      // Show success notification\n      components.ui.showNotification(\n        `The agent got the updated menu!`, \n        \"success\"\n      );\n    }\n    \n    const result = JSON.stringify({\n      success: true,\n      itemsLoaded: items.length,\n      categories: components.menu.getAllCategories(),\n      menu: [... new Set(items.map((item) => {\n        // Avoid image urls to be returned to the model for token optimization.\n        return {\n          ...item,\n          image: null\n        };\n      }))]\n    });\n    \n    return result;\n    \n  } catch (error) {\n    components.ui.showNotification(\"Failed to load sample menu\", \"error\");\n    console.log(\"Tool::Script::\"+toolName+\" error:\", error);\n    return JSON.stringify({\n      success: false,\n      error: error.message\n    });\n  }\n}",
          "run_after_app_init": true,
          "order": 3
        },
        {
          "tool_name": "AddToCart",
          "description": "This tool will allow adding items to the cart. It requires for you to read the 'id' associated to the item selected by the customer from the menu. ",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"description\": \"Array of items that are needed to be added to the cart\",\n  \"properties\": {\n    \"items\": {\n      \"type\": \"array\",\n      \"properties\": {\n        \"itemId\": {\n          \"type\": \"string\",\n          \"description\": \"This is the id of the item to add from the menu items\"\n        },\n        \"quantity\": {\n          \"type\": \"number\",\n          \"description\": \"Quantity to add\",\n          \"default\": 1\n        },\n        \"customizations\": {\n          \"type\": \"array\",\n          \"description\": \"Array of customization IDs to apply to the item\",\n          \"items\": {\n            \"type\": \"object\",\n            \"properties\": {\n              \"id\": { \n                \"type\": \"string\",\n                \"description\": \"The customization ID from the menu item's availableCustomizations\"\n              }\n            },\n            \"required\": [\"id\"]\n          }\n        }\n      },\n      \"required\": [\"itemId\"]\n    }\n  },\n  \"required\": [\"items\"]\n}"
          },
          "script": "async function execute({...args}) {\n  const { input, components, toolName, utils, axios, auth, globals } = args;\n  console.log(\"Tool::Script::\"+toolName+\" executed with input:\", JSON.stringify(input, null, 2));\n  \n  // Helper function to check if two customization arrays are the same\n  const customizationsMatch = (customizations1, customizations2) => {\n    if (!customizations1 && !customizations2) return true;\n    if (!customizations1 || !customizations2) return false;\n    if (customizations1.length !== customizations2.length) return false;\n    \n    // Sort both arrays by id for comparison\n    const sorted1 = [...customizations1].sort((a, b) => a.id.localeCompare(b.id));\n    const sorted2 = [...customizations2].sort((a, b) => a.id.localeCompare(b.id));\n    \n    return sorted1.every((custom1, index) => custom1.id === sorted2[index].id);\n  };\n\n  // Helper function to find existing cart item with same menuItemId and customizations\n  const findExistingCartItem = (menuItemId, customizations) => {\n    const currentCart = components.cart.getOrderSummary();\n    return currentCart.items.find(cartItem => \n      cartItem.menuItemId === menuItemId && \n      customizationsMatch(cartItem.customizations, customizations)\n    );\n  };\n  \n  try {\n    if(input.items.length === 0){\n      throw(\"No items passed to the tool, at least one item is needed\");\n    }\n\n    const items = input.items;\n    const itemsToAdd = [];\n    const itemsToUpdate = [];\n    const processedItems = [];\n    let cartResult = {\n      summary: {}\n    };\n\n    // Adding items in the array one by one to the cart\n    for(const element of items){\n      // Search for the item by id\n      console.log(\"Tool::Script::\"+toolName+\" getItemById:\", element.itemId);\n      let item = components.menu.getItemById(element.itemId);\n\n      //If the item could be found, we will try to search for it, in case the agent made a mistake while providing the id\n      if(!item){\n        console.log(\"Tool::Script::\"+toolName+\" no item found using id:\", element.itemId);\n        components.ui.showNotification(`Searching for item \"${element.itemId}\" `, \"info\");\n\n        const searchResult = components.menu.searchItems(element.itemId);\n        \n        console.log(\"Tool::Script::\"+toolName+\" product found for cart\", searchResult);\n\n        if(searchResult.length > 1){\n          return JSON.stringify({\n            success: true,\n            message: \"Confirm with the customer which menu item he is referring to\",\n            products: searchResult\n          });\n        }else{\n          console.log(\"Tool::Script::\"+toolName+\" product found for cart\", searchResult);\n          item = searchResult[0]\n        }\n      }\n\n      // If the item was not found despite the effort of searching for it\n      if (!item) {\n        components.ui.showNotification(`Item \"${element.itemId}\" not found`, \"error\");\n        return JSON.stringify({\n          success: false,\n          error: `Item '${element.itemId}' not found in menu`\n        });\n      }\n\n      // ========================================\n      // IMPROVED CUSTOMIZATION VALIDATION\n      // ========================================\n      \n      const customizations = [];\n      \n      try {\n        if (Array.isArray(element.customizations) && element.customizations.length > 0) {\n          console.log(\"Tool::Script::\"+toolName+\" validating customizations for:\", item.name);\n          console.log(\"Tool::Script::\"+toolName+\" requested customizations:\", element.customizations);\n          console.log(\"Tool::Script::\"+toolName+\" available customizations:\", item.availableCustomizations);\n          \n          // Validate each customization individually\n          for (const cRequested of element.customizations) {\n            const foundCustomization = item.availableCustomizations.find(cAvailable => \n              cRequested.id === cAvailable.id\n            );\n            \n            if (!foundCustomization) {\n              // Invalid customization - provide meaningful feedback\n              const availableCustomizationNames = item.availableCustomizations.length > 0 \n                ? item.availableCustomizations.map(c => c.name).join(', ')\n                : 'none';\n              \n              const errorMessage = item.availableCustomizations.length > 0\n                ? `\"${cRequested.id}\" customization is not available for ${item.name}. Available customizations: ${availableCustomizationNames}`\n                : `${item.name} does not have any customizations available`;\n              \n              console.log(\"Tool::Script::\"+toolName+\" CUSTOMIZATION ERROR:\", errorMessage);\n              \n              // Show user notification\n              components.ui.showNotification(\n                `Invalid customization: ${cRequested.id} not available for ${item.name}`, \n                \"error\"\n              );\n              \n              return JSON.stringify({\n                success: false,\n                error: errorMessage,\n                itemName: item.name,\n                requestedCustomization: cRequested.id,\n                availableCustomizations: item.availableCustomizations.map(c => ({\n                  id: c.id,\n                  name: c.name,\n                  price: c.price,\n                  isRemoval: c.isRemoval || false\n                })),\n                suggestion: item.availableCustomizations.length > 0 \n                  ? `Please choose from: ${availableCustomizationNames}`\n                  : `${item.name} cannot be customized`\n              });\n            }\n            \n            // Valid customization - add it\n            customizations.push(foundCustomization);\n            console.log(\"Tool::Script::\"+toolName+\" valid customization added:\", foundCustomization.name);\n          }\n        }\n        \n        console.log(\"Tool::Script::\"+toolName+\" final validated customizations:\", customizations);\n        \n      } catch(e) {\n        console.error(\"Tool::Script::\"+toolName+\" customization validation error:\", e);\n        return JSON.stringify({\n          success: false,\n          error: `Error processing customizations for ${item.name}: ${e.message}`\n        });\n      }\n\n      // If the item becomes unavailable, we need to tell to the agent\n      if (!item.available) {\n        return JSON.stringify({\n          success: false,\n          error: `Item id \"${element.itemId}\" is not available right now, it could be out of stock`\n        });\n      }\n\n      // Check if this item already exists in cart with same customizations\n      console.log(\"Tool::Script::\"+toolName+\" checking for existing cart item with menuItemId:\", item.id, \"and customizations:\", customizations);\n      const existingCartItem = findExistingCartItem(String(item.id), customizations);\n      \n      if (existingCartItem) {\n        // Item exists - update quantity instead of adding new\n        const newQuantity = existingCartItem.quantity + (element.quantity || 1);\n        console.log(\"Tool::Script::\"+toolName+\" found existing item:\", existingCartItem.name, \"current qty:\", existingCartItem.quantity, \"adding:\", element.quantity, \"new total:\", newQuantity);\n        \n        itemsToUpdate.push({\n          cartItemId: existingCartItem.id,\n          itemName: existingCartItem.name,\n          oldQuantity: existingCartItem.quantity,\n          addedQuantity: element.quantity || 1,\n          newQuantity: newQuantity\n        });\n        \n        // Use updateQuantity to merge\n        console.log(\"Tool::Script::\"+toolName+\" calling updateQuantity for existing item\");\n        cartResult.summary = components.cart.updateQuantity(existingCartItem.id, newQuantity);\n        console.log(\"Tool::Script::\"+toolName+\" result of updateQuantity for existing item\", cartResult);\n        // Show success notification for merge\n        components.ui.showNotification(\n          `Added ${element.quantity || 1}x ${item.name} to existing cart item (${newQuantity} total)`, \n          \"success\"\n        );\n        \n      } else {\n        // Item doesn't exist - add as new item\n        console.log(\"Tool::Script::\"+toolName+\" no existing item found, adding as new item\");\n        \n        item.menuItemId = String(item.id);\n        item.quantity = element.quantity || 1;\n        item.customizations = customizations; // Now guaranteed to be valid\n        itemsToAdd.push(item);\n        \n        // Show success notification for new item\n        const customizationText = customizations.length > 0 \n          ? ` with ${customizations.map(c => c.name).join(', ')}`\n          : '';\n        \n        components.ui.showNotification(\n          `Added ${item.quantity}x ${item.name}${customizationText} to cart`, \n          \"success\"\n        );\n      }\n      \n      // Highlight the item in the menu\n      components.menu.highlightItem(item.id, 3000);\n      \n      processedItems.push({\n        itemId: element.itemId,\n        itemName: item.name,\n        quantity: element.quantity || 1,\n        action: existingCartItem ? 'merged' : 'added',\n        customizations: customizations\n      });\n    }\n\n    // Add new items to cart (if any) and capture combo information\n    let comboApplied = null;\n    \n    if (itemsToAdd.length > 0) {\n      console.log(\"Tool::Script::\"+toolName+\" adding\", itemsToAdd.length, \"new items to cart\");\n      cartResult = components.cart.bulkAddToCart(itemsToAdd);\n      console.log(\"Tool::Script::\"+toolName+\" bulkAddToCart result:\", JSON.stringify(cartResult, null, 2));\n      \n      // Check if combo was applied\n      if (cartResult && cartResult.comboApplied) {\n        comboApplied = cartResult.comboApplied;\n        console.log(\"Tool::Script::\"+toolName+\" COMBO DETECTED:\", comboApplied.comboName, \"savings:\", comboApplied.savings);\n        \n        // Show combo notification\n        components.ui.showNotification(\n          `🎉 ${comboApplied.comboName} applied! Saved $${comboApplied.savings.toFixed(2)}`, \n          \"success\"\n        );\n      }\n    }\n\n    // Sending cart item to the API for synchronization\n    const tokens = await auth.getTokens();\n    const payload = {\n      deviceId: utils.getDeviceId(),\n      loyaltyId: input.loyaltyId || \"null\",\n      cartSummary: JSON.stringify(cartResult.summary).replace(/\"/g, '\\\\\"')\n    }\n    console.log(\"Tool::Script::\"+toolName+\" syncing with API:\", JSON.stringify(payload, null, 2));\n    \n    axios.post(\n      globals.cartAPIURL,\n      payload,\n      {\n        headers: {\n          \"Authorization\": `${tokens.idToken}`,\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n    // Include combo information in the result\n    const result = JSON.stringify({\n      success: true,\n      processedItems: processedItems,\n      newItems: cartResult ? cartResult.addedItems : [],\n      updatedItems: itemsToUpdate,\n      cartSummary: cartResult.summary,\n      ...(comboApplied && { comboApplied })\n    }); \n    \n    console.log(\"Tool::Script::\"+toolName+\" executed with output:\", result);\n    \n    return result;\n    \n  } catch (error) {\n    console.error(\"Tool::Script::\"+toolName+\" error:\", error);\n    components.ui.showNotification(\"Failed to add item to cart\", \"error\");\n    return JSON.stringify({\n      success: false,\n      error: error.message\n    });\n  }\n}",
          "run_after_app_init": false,
          "order": 4
        },
        {
          "tool_name": "addCustomizationToCartItem",
          "description": "This tools will add customization to an item previously added to the cart using the cartItemId",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"cartItemId\": {\n      \"type\": \"string\",\n      \"description\": \"The id of the item in the cart, this can be obteined from getCurrentCartItems\"\n    },\n    \"customizations\": {\n      \"type\": \"array\",\n      \"description\": \"Array of customization IDs to apply to the item\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"id\": { \n            \"type\": \"string\",\n            \"description\": \"The customization ID from the menu item's availableCustomizations\"\n          }\n        },\n        \"required\": [\"id\"]\n      }\n    }\n  },\n  \"required\": [\"cartItemId\", \"customizations\"]\n}"
          },
          "script": "async function execute({...args}) {\n  const { input, toolName, components } = args;\n\n  console.log(\"Tool::Script::\"+toolName+\" executed input:\", input);\n  const cartItem = components.cart.getCartItem(input.cartItemId);\n  console.log(\"Tool::Script::\"+toolName+\" cart item:\", cartItem);\n  const menuItem = components.menu.getItemById(cartItem.menuItemId)\n  console.log(\"Tool::Script::\"+toolName+\" item to update:\", menuItem);\n  const customizations = []\n  try{\n    if(Array.isArray(input.customizations) && input.customizations.length > 0){\n      customizations.push(...input.customizations.map((cRequested) => {\n        return menuItem.availableCustomizations.find(cAvailable => \n          cRequested.id === cAvailable.id\n        )\n      })) \n    }\n    console.log(\"Tool::Script::\"+toolName+\" customizations: \", customizations);\n  }catch(e){\n    console.error(\"Tool::Script::\"+toolName+\" customizations: \", e);\n  }\n  let item;\n  for(let customization of customizations){\n    item = await components.cart.addCustomizationToCartItem(input.cartItemId, customization)\n  }\n  const orderSummary = components.cart.getOrderSummary();\n  // Always return a JSON string\n  return JSON.stringify({ \n    result: \"success\",\n    message: \"Tool executed successfully\",\n    itemModified: item,\n    cartSummary: orderSummary\n  });\n}",
          "run_after_app_init": false,
          "order": 5
        },
        {
          "tool_name": "RemoveItemFromCart",
          "description": "This tool will help you remove an item that was incorrectly added to the cart, you can also use it to modify and incorrect entry by removing and adding the item correctly typed",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"description\": \"Remove items from cart using either exact cart item IDs or natural language descriptions\",\n  \"properties\": {\n    \"items\": {\n      \"type\": \"array\",\n      \"description\": \"Array of items to remove using exact cart item IDs (existing format)\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"cartItemId\": {\n            \"type\": \"string\",\n            \"description\": \"Exact ID of the cart item to remove\"\n          },\n          \"quantity\": {\n            \"type\": \"number\",\n            \"description\": \"Quantity to remove\"\n          }\n        },\n        \"required\": [\"cartItemId\", \"quantity\"]\n      }\n    },\n    \"itemsToRemove\": {\n      \"type\": \"array\", \n      \"description\": \"Array of items to remove using natural language descriptions (smart format)\",\n      \"items\": {\n        \"type\": \"object\",\n        \"properties\": {\n          \"itemDescription\": {\n            \"type\": \"string\",\n            \"description\": \"Natural language description of item to remove (e.g., 'burger combo', 'the cheese burger', 'combo')\"\n          },\n          \"quantity\": {\n            \"type\": \"number\",\n            \"description\": \"Quantity to remove\",\n            \"default\": 1\n          }\n        },\n        \"required\": [\"itemDescription\"]\n      }\n    }\n  },\n  \"oneOf\": [\n    {\"required\": [\"items\"]},\n    {\"required\": [\"itemsToRemove\"]}\n  ]\n}"
          },
          "script": "async function execute({...args}) {\n  const { input, components, toolName, utils } = args;\n  console.log(\"Tool::Script::\" + toolName + \" executed with input:\", JSON.stringify(input, null, 2));\n  \n  try {\n    // Check if using existing format (cartItemId)\n    if (input.items && Array.isArray(input.items) && input.items.length > 0 && input.items[0].cartItemId) {\n      console.log(\"Tool::Script::\" + toolName + \" using EXISTING format (cartItemId)\");\n      return await executeExistingLogic(input, components, toolName);\n    }\n    \n    // Check if using new smart format (itemDescription)\n    if (input.itemsToRemove && Array.isArray(input.itemsToRemove) && input.itemsToRemove.length > 0) {\n      console.log(\"Tool::Script::\" + toolName + \" using NEW smart format (itemDescription)\");\n      return await executeSmartLogic(input, components, toolName);\n    }\n    \n    throw new Error(\"Invalid input format. Use either 'items' with 'cartItemId' or 'itemsToRemove' with 'itemDescription'\");\n    \n  } catch (error) {\n    console.error(\"Tool::Script::\" + toolName + \" error:\", error);\n    components.ui.showNotification(\"Failed to remove items from cart\", \"error\");\n    return JSON.stringify({\n      success: false,\n      error: error.message\n    });\n  }\n}\n\n// Existing logic (unchanged)\nasync function executeExistingLogic(input, components, toolName) {\n  console.log(\"Tool::Script::\" + toolName + \" EXISTING LOGIC: processing\", input.items.length, \"items\");\n  const processedItems = [];\n  \n  for (const element of input.items) {\n    console.log(\"Tool::Script::\" + toolName + \" processing item:\", JSON.stringify(element, null, 2));\n    \n    const cartItem = components.cart.getCartItem(element.cartItemId);\n    console.log(\"Tool::Script::\" + toolName + \" getCartItem result:\", JSON.stringify(cartItem, null, 2));\n    \n    if (!cartItem) {\n      console.error(\"Tool::Script::\" + toolName + \" ERROR: Cart item with ID\", element.cartItemId, \"not found\");\n      components.ui.showNotification(`Cart item with ID \"${element.cartItemId}\" not found in cart`, \"error\");\n      continue;\n    }\n\n    const newQuantity = cartItem.quantity - element.quantity;\n    console.log(\"Tool::Script::\" + toolName + \" quantity calculation:\", cartItem.quantity, \"-\", element.quantity, \"=\", newQuantity);\n    \n    if (newQuantity < 0) {\n      console.error(\"Tool::Script::\" + toolName + \" ERROR: Cannot remove\", element.quantity, \"items. Only\", cartItem.quantity, \"available\");\n      components.ui.showNotification(`Cannot remove ${element.quantity} items. Only ${cartItem.quantity} available in cart`, \"error\");\n      continue;\n    }\n\n    console.log(\"Tool::Script::\" + toolName + \" calling components.cart.updateQuantity with cartItemId:\", element.cartItemId, \"newQuantity:\", newQuantity);\n    const updateResult = components.cart.updateQuantity(element.cartItemId, newQuantity);\n    console.log(\"Tool::Script::\" + toolName + \" updateQuantity result:\", JSON.stringify(updateResult, null, 2));\n    \n    processedItems.push({\n      cartItemId: element.cartItemId,\n      itemName: cartItem.name,\n      removedQuantity: element.quantity,\n      newQuantity: newQuantity,\n      action: newQuantity === 0 ? 'removed' : 'updated'\n    });\n\n    if (newQuantity === 0) {\n      console.log(\"Tool::Script::\" + toolName + \" item completely removed\");\n      components.ui.showNotification(`Removed all ${cartItem.name} from cart`, \"success\");\n    } else {\n      console.log(\"Tool::Script::\" + toolName + \" item quantity updated\");\n      components.ui.showNotification(`Removed ${element.quantity}x ${cartItem.name} from cart (${newQuantity} remaining)`, \"success\");\n    }\n  }\n\n  const finalCartSummary = components.cart.getOrderSummary();\n  console.log(\"Tool::Script::\" + toolName + \" final cart summary:\", JSON.stringify(finalCartSummary, null, 2));\n\n  const success = processedItems.length > 0;\n  const result = JSON.stringify({\n    success: success,\n    processedItems: processedItems,\n    cartSummary: finalCartSummary\n  }); \n\n  console.log(\"Tool::Script::\" + toolName + \" EXISTING LOGIC executed with output:\", result);\n  return result;\n}\n\n// SIMPLIFIED Smart Logic - Focus on the core issue\nasync function executeSmartLogic(input, components, toolName) {\n  console.log(\"Tool::Script::\" + toolName + \" SMART LOGIC: processing\", input.itemsToRemove.length, \"item descriptions\");\n  \n  const currentCart = components.cart.getOrderSummary();\n  console.log(\"Tool::Script::\" + toolName + \" current cart:\", JSON.stringify(currentCart, null, 2));\n  \n  if (!currentCart.items || currentCart.items.length === 0) {\n    components.ui.showNotification(\"Your cart is empty\", \"info\");\n    return JSON.stringify({\n      success: false,\n      error: \"Cart is empty\",\n      cartSummary: currentCart\n    });\n  }\n  \n  const processedItems = [];\n  const clarificationNeeded = [];\n  \n  for (const element of input.itemsToRemove) {\n    const itemDescription = element.itemDescription?.toLowerCase().trim();\n    const requestedQuantity = element.quantity || 1;\n    \n    if (!itemDescription) {\n      console.log(\"Tool::Script::\" + toolName + \" skipping empty item description\");\n      continue;\n    }\n    \n    console.log(\"Tool::Script::\" + toolName + \" looking for:\", itemDescription);\n    \n    // SIMPLE MATCHING LOGIC - Focus on the core issue\n    const matches = currentCart.items.filter(cartItem => {\n      const itemName = cartItem.name.toLowerCase();\n      console.log(\"Tool::Script::\" + toolName + \" checking:\", cartItem.name, \"against:\", itemDescription);\n      \n      // RULE 1: If customer mentions \"with [customization]\", only match items that have that customization\n      if (itemDescription.includes('with ')) {\n        // Extract what they want: \"milkshake with whipped cream\" -> \"whipped cream\"\n        const wantedCustomization = itemDescription.replace(/.*with\\s+/, '').trim();\n        \n        // Only match items that have customizations (~)\n        if (itemName.includes('~')) {\n          const itemCustomizations = itemName.split('~')[1];\n          // Clean up pricing and check if it contains what they want\n          const cleanCustomizations = itemCustomizations\n            .replace(/\\(\\+\\$[\\d.]+\\)/g, '')\n            .replace(/\\(\\-\\$[\\d.]+\\)/g, '')\n            .trim()\n            .toLowerCase();\n          \n          // Check if the customization matches\n          if (cleanCustomizations.includes(wantedCustomization)) {\n            console.log(\"Tool::Script::\" + toolName + \" CUSTOMIZATION match:\", cartItem.name);\n            return true;\n          }\n        }\n        // If they want customization but this item has none, don't match\n        return false;\n      }\n      \n      // RULE 2: If customer says just the base item name, match all variants\n      const baseItemName = itemName.split('~')[0].trim();\n      if (baseItemName.toLowerCase().includes(itemDescription) || itemDescription.includes(baseItemName.toLowerCase())) {\n        console.log(\"Tool::Script::\" + toolName + \" BASE match:\", cartItem.name);\n        return true;\n      }\n      \n      return false;\n    });\n    \n    console.log(\"Tool::Script::\" + toolName + \" found\", matches.length, \"matches for:\", itemDescription);\n    matches.forEach(match => console.log(\"Tool::Script::\" + toolName + \" - Match:\", match.name));\n    \n    if (matches.length === 0) {\n      const availableItems = currentCart.items.map(item => item.name).join(', ');\n      console.log(\"Tool::Script::\" + toolName + \" no matches found\");\n      \n      return JSON.stringify({\n        success: false,\n        error: `\"${element.itemDescription}\" not found in your cart`,\n        availableItems: currentCart.items.map(item => ({\n          id: item.id,\n          name: item.name,\n          quantity: item.quantity\n        })),\n        message: `I don't see \"${element.itemDescription}\" in your cart. Available items: ${availableItems}`,\n        cartSummary: currentCart\n      });\n      \n    } else if (matches.length === 1) {\n      // Single match - remove directly\n      const cartItem = matches[0];\n      console.log(\"Tool::Script::\" + toolName + \" single match found:\", cartItem.name);\n      \n      if (requestedQuantity > cartItem.quantity) {\n        components.ui.showNotification(`Cannot remove ${requestedQuantity}x ${cartItem.name}. Only ${cartItem.quantity} available`, \"error\");\n        continue;\n      }\n      \n      const newQuantity = cartItem.quantity - requestedQuantity;\n      console.log(\"Tool::Script::\" + toolName + \" removing\", requestedQuantity, \"from\", cartItem.quantity, \"=\", newQuantity);\n      \n      const updateResult = components.cart.updateQuantity(cartItem.id, newQuantity);\n      console.log(\"Tool::Script::\" + toolName + \" updateQuantity result:\", JSON.stringify(updateResult, null, 2));\n      \n      processedItems.push({\n        cartItemId: cartItem.id,\n        itemName: cartItem.name,\n        removedQuantity: requestedQuantity,\n        newQuantity: newQuantity,\n        action: newQuantity === 0 ? 'removed' : 'updated'\n      });\n      \n      if (newQuantity === 0) {\n        components.ui.showNotification(`Removed all ${cartItem.name} from cart`, \"success\");\n      } else {\n        components.ui.showNotification(`Removed ${requestedQuantity}x ${cartItem.name} from cart (${newQuantity} remaining)`, \"success\");\n      }\n      \n    } else {\n      // Multiple matches - need clarification\n      console.log(\"Tool::Script::\" + toolName + \" multiple matches found, need clarification\");\n      \n      clarificationNeeded.push({\n        requestedItem: element.itemDescription,\n        matches: matches.map(item => ({\n          id: item.id,\n          name: item.name,\n          quantity: item.quantity,\n          price: item.totalPrice\n        }))\n      });\n    }\n  }\n  \n  // Handle clarification - Simple and clear\n  if (clarificationNeeded.length > 0) {\n    const clarificationItem = clarificationNeeded[0];\n    \n    // Create clear descriptions - SIMPLE approach\n    const matchNames = clarificationItem.matches.map((match, index) => {\n      // Simple description with quantity for clarity\n      const hasCustomizations = match.name.includes('~') || match.name.includes('with') || match.name.includes('+');\n      \n      if (hasCustomizations) {\n        return `${match.name} (${match.quantity} qty)`;\n      } else {\n        return `${match.name} (${match.quantity} qty, regular)`;\n      }\n    }).join(' or ');\n    \n    return JSON.stringify({\n      success: false,\n      requiresClarification: true,\n      requestedItem: clarificationItem.requestedItem,\n      matches: clarificationItem.matches,\n      message: `I found ${clarificationItem.matches.length} items matching \"${clarificationItem.requestedItem}\": ${matchNames}. Which one would you like me to remove?`,\n      cartSummary: currentCart\n    });\n  }\n  \n  const finalCartSummary = components.cart.getOrderSummary();\n  console.log(\"Tool::Script::\" + toolName + \" final cart summary:\", JSON.stringify(finalCartSummary, null, 2));\n  \n  const result = JSON.stringify({\n    success: true,\n    processedItems: processedItems,\n    cartSummary: finalCartSummary,\n    method: \"smart_matching\"\n  });\n  \n  console.log(\"Tool::Script::\" + toolName + \" SMART LOGIC executed with output:\", result);\n  return result;\n}",
          "run_after_app_init": false,
          "order": 6
        },
        {
          "tool_name": "GetCurrentCartItems",
          "description": "The the current cart items and total",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"properties\": {},\n  \"required\": []\n}"
          },
          "script": "async function execute({...args}) {\n  const { toolName, components } = args;\n  const orderSummary = components.cart.getOrderSummary();\n  console.log(\"Tool::Script::\"+toolName+\" current cart:\", orderSummary);\n  // Always return a JSON string\n  return JSON.stringify({ \n    result: \"success\",\n    currentCartItems: orderSummary\n  });\n}",
          "run_after_app_init": false,
          "order": 7
        },
        {
          "tool_name": "ShowCategoryItems",
          "description": "This tool will allow you to keep the conversation in context with what the customer is watching on the screen. Throughout the conversation, you can call this tool to highlight the category you want to bring focus or as an up selling strategy",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"properties\": {\n    \"category\": {\n      \"type\": \"string\",\n      \"description\": \"Category to show (e.g., burgers, wings, drinks, fries, desserts)\"\n    }\n  },\n  \"required\": [\"category\"]\n}"
          },
          "script": "async function execute({...args}) {\n  const { input, components } = args;\n  //console.log(\"Tool::Script::\"+toolName+\" executed with input:\", input);\n  try {\n    const categories = components.menu.getAllCategories();\n    \n    // Find category by name or ID (case insensitive)\n    const targetCategory = categories.find(cat => \n      cat.id.toLowerCase() === input.category.toLowerCase() || \n      cat.name.toLowerCase() === input.category.toLowerCase() ||\n      cat.displayName.toLowerCase() === input.category.toLowerCase()\n    );\n    \n    if (!targetCategory) {\n      const availableCategories = categories.map(cat => cat.displayName).join(', ');\n      components.ui.showNotification(\n        `Category \"${input.category}\" not found. Available: ${availableCategories}`, \n        \"warning\"\n      );\n      const result = JSON.stringify({\n        success: false,\n        error: `Category '${input.category}' not found`,\n        availableCategories: categories.map(cat => cat.displayName)\n      });\n      //console.log(\"Tool::Script::\"+toolName+\" executed with output:\", result);\n      return result;\n    }\n    \n    // Set the active category (same as clicking the category button)\n    components.menu.showCategory(targetCategory.id)\n    components.menu.setActiveCategory(targetCategory.id);\n    \n    // Get items in this category\n    const items = components.menu.getMenuItems(targetCategory.id);\n    //console.log(\"Tool::Script::\"+toolName+\" items:\", JSON.stringify(items,null,2));\n\n    const result = JSON.stringify({\n      success: true,\n      category: targetCategory.displayName,\n      itemCount: items.length,\n      items: items\n    });\n    // console.log(\"Tool::Script::\"+toolName+\" executed with output:\", result);\n    return result;\n    \n  } catch (error) {\n    return JSON.stringify({\n      success: false,\n      error: error.message\n    });\n  }\n}",
          "run_after_app_init": false,
          "order": 8
        },
        {
          "tool_name": "GetCategoryList",
          "description": "This tool will allow you to get the list of available categories to avoid errors during the selection of them in another tool. Get this list to keep your conversation in context",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"properties\": {},\n  \"required\": []\n}"
          },
          "script": "async function execute({...args}) {\n  const { components, toolName} = args;\n  const categories = components.menu.getAllCategories();\n  \n  // Always return a JSON string\n  return JSON.stringify({ \n    result: \"success\",\n    categories: categories\n  });\n}",
          "run_after_app_init": false,
          "order": 9
        },
        {
          "tool_name": "SubmitOrder",
          "description": "This tool will be that last one to use when the customer is ready to move for payment. By using this tool, you will be cleaning the chat and cart and leaving the interface ready for the next customer",
          "inputSchema": {
            "json": "{\n  \"tool_name\": \"SubmitOrder\",\n  \"description\": \"Submit the current order to the kitchen and save chat history to database\",\n  \"inputSchema\": {\n    \"type\": \"object\",\n    \"properties\": {},\n    \"required\": []\n  },\n  \"run_after_app_init\": false,\n  \"order\": 20\n}"
          },
          "script": "async function execute({...args}) {\n  const { toolName, components, axios, auth, globals } = args;\n  console.log(\"Tool::Script::\" + toolName + \" executed with args:\", args);\n  \n  try {\n    // Get order summary and chat messages\n    const orderSummary = components.cart.getOrderSummary();\n    const chatMessages = components.chat.getMessagesForStorage();\n    \n    console.log(\"Tool::Script::\" + toolName + \" orderSummary\", orderSummary);\n    console.log(\"Tool::Script::\" + toolName + \" chatMessages\", chatMessages);\n    \n    // Get authentication tokens\n    const tokens = await auth.getTokens();\n    if (!tokens.idToken) {\n      throw new Error(\"No access token available\");\n    }\n\n    console.log(\"Tool::Script::\"+ toolName +\" idToken:\", tokens.idToken);\n    \n    // Step 1: Submit order to get orderId\n    const orderData = {\n      customerId: \"drive-thru-customer\",\n      total: orderSummary.total,\n      items: JSON.stringify(orderSummary.items).replace(/\"/g, '\\\\\"')\n    };\n    \n    console.log(\"Tool::Script::\" + toolName + \" sending order data:\", orderData);\n    \n    const orderResponse = await axios.post(\n      globals.orderAPIURL,\n      orderData,\n      {\n        headers: {\n          \"Authorization\": `${tokens.idToken}`,\n          \"Content-Type\": \"application/json\"\n        }\n      }\n    );\n    \n    console.log(\"Tool::Script::\" + toolName + \" order API response:\", orderResponse.data);\n    const orderId = orderResponse.data.orderId;\n    \n    // Step 2: Save all chat messages in one batch request\n    if (chatMessages.length > 0) {\n      console.log(\"Tool::Script::\" + toolName + \" saving chat history batch for orderId:\", orderId);\n      \n      // Prepare messages for batch save\n      const messagesForBatch = chatMessages.map(message => ({\n        orderId: orderId,\n        timestamp: message.createdAt,\n        role: message.role,\n        message: message.message,\n        messageId: message.messageId\n      }));\n      \n      const chatBatchData = {\n        messages: messagesForBatch\n      };\n      \n      console.log(\"Tool::Script::\" + toolName + \" sending chat batch data:\", chatBatchData);\n      \n      const chatResponse = await axios.post(\n        globals.chatAPIURL,\n        chatBatchData,\n        {\n          headers: {\n            \"Authorization\": `${tokens.idToken}`,\n            \"Content-Type\": \"application/json\"\n          }\n        }\n      );\n      \n      console.log(\"Tool::Script::\" + toolName + \" chat batch API response:\", chatResponse.data);\n    }\n    \n    // // Step 3: Clear cart and show success\n    // components.cart.clearCart();\n    \n    // // Show success notification\n    // components.ui.showNotification(\n    //   \"Order submitted successfully! Please move to the next window for payment.\",\n    //   \"success\"\n    // );\n    \n    // Add confirmation message to chat\n    components.chat.addMessage(\n      `Order #${orderId} has been sent to the kitchen. Total: $${orderSummary.total.toFixed(2)}`,\n      \"system\"\n    );\n    \n    return JSON.stringify({\n      success: true,\n      result: \"success\",\n      message: \"Order sent to the kitchen\",\n      instructionsForCachierAgent: \"You can now finalize the session. From here you can only mention what is on the message, anything else will be irrelevant for the customer\",\n      orderId: orderId,\n      orderSummary: orderSummary,\n      chatMessagesSaved: chatMessages.length\n    });\n    \n  } catch (error) {\n    console.error(\"Tool::Script::\" + toolName + \" error:\", error);\n    \n    // Show error notification\n    components.ui.showNotification(\n      \"Failed to submit order. Please try again.\",\n      \"error\"\n    );\n    \n    return JSON.stringify({\n      success: false,\n      error: error.message,\n      message: \"Failed to submit order. Please try again.\"\n    });\n  }\n}",
          "run_after_app_init": false,
          "order": 10
        },
        {
          "tool_name": "FinalizeSessionForNextCustomer",
          "description": "This tool will help you to clean the screen and leave it ready for the next customer. It should be used only after the order has been submitted. ",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"properties\": {},\n  \"required\": []\n}"
          },
          "script": "async function execute({...args}) {\n  const { components, toolName, utils } = args;\n  console.log(\"Tool::Script::\" + toolName + \" executed with args:\", args);\n  const endSessionMessage = \"Thank you for your order! Please move to the next window for payment...\"\n  const startSessionMessage = \"Welcome, connecting with cachier...\"\n  components.app.stopUI(true, endSessionMessage, 10, () => {\n    components.app.startUI(startSessionMessage, true);\n  });\n  return JSON.stringify({ \n    result: \"success\",\n    message: \"Tool executed successfully\",\n    instructionsForCachierAgent: `You can now tell the customer: ${endSessionMessage}`\n  });\n}",
          "run_after_app_init": false,
          "order": 11
        },
        {
          "tool_name": "MenuValidation",
          "description": "This Tool validates if a requested item exists in the menu and returns the exact menu ID or suggests alternatives. Use this tool BEFORE calling AddToCart to ensure item availability.",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"description\": \"Validates menu item availability and returns exact menu ID or suggestions\",\n  \"properties\": {\n    \"requestedItem\": {\n      \"type\": \"string\",\n      \"description\": \"The item name or description that the customer requested (e.g., 'lemon milkshake', 'cheese burger', 'buffalo wings')\"\n    }\n  },\n  \"required\": [\n    \"requestedItem\"\n  ]\n}"
          },
          "script": "async function execute({...args}) {\n  const { input, components, toolName } = args;\n  console.log(\"Tool::Script::\"+toolName+\" executed with input:\", JSON.stringify(input, null, 2));\n  \n  try {\n    if (!input.requestedItem || input.requestedItem.trim() === '') {\n      return JSON.stringify({\n        success: false,\n        error: \"No item specified for validation\"\n      });\n    }\n\n    const requestedItem = input.requestedItem.toLowerCase().trim();\n    console.log(\"Tool::Script::\"+toolName+\" validating item:\", requestedItem);\n\n    // Get all available menu categories\n    const allCategories = components.menu.getAllCategories();\n    let allMenuItems = [];\n    \n    // Collect all menu items from all categories\n    allCategories.forEach(category => {\n      const categoryItems = components.menu.getMenuItems(category.id);\n      if (categoryItems && categoryItems.length > 0) {\n        allMenuItems = allMenuItems.concat(categoryItems);\n      }\n    });\n    \n    // Remove duplicates based on item ID\n    allMenuItems = allMenuItems.filter((item, index, self) => \n      index === self.findIndex(i => i.id === item.id)\n    );\n    \n    console.log(\"Tool::Script::\"+toolName+\" searching among\", allMenuItems.length, \"menu items\");\n    \n    // 1. EXACT NAME MATCH (case insensitive)\n    const exactMatch = allMenuItems.find(item => \n      item.name.toLowerCase() === requestedItem\n    );\n    \n    if (exactMatch) {\n      console.log(\"Tool::Script::\"+toolName+\" EXACT MATCH found:\", exactMatch.name);\n      return JSON.stringify({\n        success: true,\n        matchType: \"exact\",\n        validatedItem: {\n          id: exactMatch.id,\n          name: exactMatch.name,\n          price: exactMatch.price,\n          category: exactMatch.category,\n          available: exactMatch.available\n        },\n        message: `Found exact match: ${exactMatch.name}`,\n        instruction: `Use itemId: \"${exactMatch.id}\" for AddToCart`\n      });\n    }\n    \n    // 2. PARTIAL MATCHES (contains search term or word matches)\n    const partialMatches = allMenuItems.filter(item => {\n      const itemName = item.name.toLowerCase();\n      \n      // Direct substring match\n      if (itemName.includes(requestedItem) || requestedItem.includes(itemName)) {\n        return true;\n      }\n      \n      // Word-by-word matching\n      const requestedWords = requestedItem.split(/[\\s_-]+/).filter(word => word.length > 2);\n      const itemWords = itemName.split(/[\\s_-]+/).filter(word => word.length > 2);\n      \n      // Check if any requested word matches any item word\n      return requestedWords.some(reqWord => \n        itemWords.some(itemWord => \n          itemWord.includes(reqWord) || reqWord.includes(itemWord)\n        )\n      );\n    });\n    \n    if (partialMatches.length > 0) {\n      console.log(\"Tool::Script::\"+toolName+\" PARTIAL MATCHES found:\", partialMatches.length);\n      \n      // Sort by relevance (prioritize items that start with search term, then by length)\n      partialMatches.sort((a, b) => {\n        const aName = a.name.toLowerCase();\n        const bName = b.name.toLowerCase();\n        \n        // Prioritize items that start with the search term\n        const aStarts = aName.startsWith(requestedItem);\n        const bStarts = bName.startsWith(requestedItem);\n        if (aStarts && !bStarts) return -1;\n        if (!aStarts && bStarts) return 1;\n        \n        // Then prioritize items that contain the search term early\n        const aIndex = aName.indexOf(requestedItem);\n        const bIndex = bName.indexOf(requestedItem);\n        if (aIndex !== -1 && bIndex !== -1) {\n          if (aIndex !== bIndex) return aIndex - bIndex;\n        }\n        \n        // Finally by length (shorter = more relevant)\n        return aName.length - bName.length;\n      });\n      \n      return JSON.stringify({\n        success: false,\n        matchType: \"partial\",\n        error: `\"${input.requestedItem}\" is not available in our menu`,\n        suggestions: partialMatches.slice(0, 3).map(item => ({\n          id: item.id,\n          name: item.name,\n          price: item.price\n        })),\n        message: `Did you mean: ${partialMatches.slice(0, 3).map(item => item.name).join(', ')}?`,\n        instruction: \"Please confirm which item you'd like, then use the exact itemId for AddToCart\"\n      });\n    }\n    \n    // 3. CATEGORY-BASED SUGGESTIONS (Dynamic - no hardcoding)\n    // Extract potential category hints from the requested item\n    const requestedWords = requestedItem.split(/[\\s_-]+/).filter(word => word.length > 2);\n    let categoryMatches = [];\n    \n    // Check if any word in the request matches any category name\n    allCategories.forEach(category => {\n      const categoryName = category.name.toLowerCase();\n      const categoryDisplayName = category.displayName.toLowerCase();\n      \n      const matchesCategory = requestedWords.some(word => \n        categoryName.includes(word) || \n        categoryDisplayName.includes(word) ||\n        word.includes(categoryName) ||\n        word.includes(categoryDisplayName)\n      );\n      \n      if (matchesCategory) {\n        const categoryItems = allMenuItems.filter(item => \n          item.category && item.category.some(cat => \n            cat.toLowerCase() === category.name.toLowerCase() ||\n            cat.toLowerCase() === category.displayName.toLowerCase()\n          )\n        );\n        \n        if (categoryItems.length > 0) {\n          categoryMatches = categoryMatches.concat(categoryItems);\n        }\n      }\n    });\n    \n    // Remove duplicates from category matches\n    categoryMatches = categoryMatches.filter((item, index, self) => \n      index === self.findIndex(i => i.id === item.id)\n    );\n    \n    if (categoryMatches.length > 0) {\n      console.log(\"Tool::Script::\"+toolName+\" CATEGORY MATCHES found:\", categoryMatches.length);\n      return JSON.stringify({\n        success: false,\n        matchType: \"category\",\n        error: `\"${input.requestedItem}\" is not available in our menu`,\n        suggestions: categoryMatches.slice(0, 5).map(item => ({\n          id: item.id,\n          name: item.name,\n          price: item.price\n        })),\n        message: `We don't have \"${input.requestedItem}\", but here are some options that might interest you: ${categoryMatches.slice(0, 3).map(item => item.name).join(', ')}`,\n        instruction: \"Please choose from these options, then use the exact itemId for AddToCart\"\n      });\n    }\n    \n    // 4. NO MATCHES FOUND\n    console.log(\"Tool::Script::\"+toolName+\" NO MATCHES found for:\", requestedItem);\n    return JSON.stringify({\n      success: false,\n      matchType: \"none\",\n      error: `\"${input.requestedItem}\" is not available in our menu`,\n      message: \"Please choose from our available menu items or ask me to show you our menu categories\",\n      instruction: \"Use GetMenuItems to see all available options, then use exact itemId for AddToCart\",\n      availableCategories: allCategories.map(cat => cat.displayName)\n    });\n    \n  } catch (error) {\n    console.error(\"Tool::Script::\"+toolName+\" error:\", error);\n    return JSON.stringify({\n      success: false,\n      error: `Error validating menu item: ${error.message}`\n    });\n  }\n}",
          "run_after_app_init": false,
          "order": 12
        },
        {
          "tool_name": "ReplaceComboItem",
          "description": "Replace a specific item within an existing combo (e.g., replace cola with lemonade in burger combo)",
          "inputSchema": {
            "json": "{\n  \"type\": \"object\",\n  \"description\": \"Replace a specific item within an existing combo with a different menu item\",\n  \"properties\": {\n    \"comboCartItemId\": {\n      \"type\": \"string\",\n      \"description\": \"Cart ID of the combo to modify\"\n    },\n    \"oldItemName\": {\n      \"type\": \"string\",\n      \"description\": \"Name of the item to replace (e.g., 'cola', 'fries')\"\n    },\n    \"newItemId\": {\n      \"type\": \"string\",\n      \"description\": \"Menu ID of the replacement item\"\n    }\n  },\n  \"required\": [\n    \"comboCartItemId\",\n    \"oldItemName\",\n    \"newItemId\"\n  ]\n}"
          },
          "script": "async function execute({...args}) {\n  const { input, components, toolName, utils } = args;\n  console.log(\"Tool::Script::\" + toolName + \" executed with input:\", JSON.stringify(input, null, 2));\n  \n  try {\n    // Get the combo from cart\n    const comboItem = components.cart.getCartItem(input.comboCartItemId);\n    if (!comboItem) {\n      return JSON.stringify({\n        success: false,\n        error: \"Combo not found in cart\"\n      });\n    }\n    \n    // Get replacement item from menu\n    const newItem = components.menu.getItemById(input.newItemId);\n    if (!newItem) {\n      return JSON.stringify({\n        success: false,\n        error: \"Replacement item not found in menu\"\n      });\n    }\n    \n    // Use existing comboItems if available, otherwise get from menu\n    let currentComboItems;\n    if (comboItem.comboItems && comboItem.comboItems.length > 0) {\n      // Use existing modified combo items\n      currentComboItems = [...comboItem.comboItems];\n      console.log(\"Tool::Script::\" + toolName + \" using existing combo items:\", currentComboItems);\n    } else {\n      // Get original combo definition from menu\n      const comboMenuData = components.menu.getItemById(comboItem.menuItemId);\n      if (!comboMenuData || !comboMenuData.items) {\n        return JSON.stringify({\n          success: false,\n          error: \"Combo structure not found in menu\"\n        });\n      }\n      \n      // Create initial combo items from menu data\n      currentComboItems = comboMenuData.items.map(item => ({\n        id: item.id,\n        name: item.name,\n        price: item.price,\n        isReplacement: false\n      }));\n      console.log(\"Tool::Script::\" + toolName + \" created initial combo items from menu:\", currentComboItems);\n    }\n    \n    // Find the item to replace in current combo items\n    const itemToReplaceIndex = currentComboItems.findIndex(item => \n      item.name.toLowerCase().includes(input.oldItemName.toLowerCase()) ||\n      input.oldItemName.toLowerCase().includes(item.name.toLowerCase()) ||\n      (item.originalName && item.originalName.toLowerCase().includes(input.oldItemName.toLowerCase()))\n    );\n    \n    if (itemToReplaceIndex === -1) {\n      return JSON.stringify({\n        success: false,\n        error: `Item \"${input.oldItemName}\" not found in ${comboItem.name}`,\n        availableItems: currentComboItems.map(item => item.name)\n      });\n    }\n    \n    const itemToReplace = currentComboItems[itemToReplaceIndex];\n    console.log(\"Tool::Script::\" + toolName + \" found item to replace:\", itemToReplace);\n    \n    // Calculate price difference (use original price if this was already a replacement)\n    const originalPrice = itemToReplace.originalPrice || itemToReplace.price;\n    const priceDifference = newItem.price - originalPrice;\n    \n    // Replace the item in the combo items array\n    currentComboItems[itemToReplaceIndex] = {\n      id: newItem.id,\n      name: newItem.name,\n      price: newItem.price,\n      isReplacement: true,\n      originalName: itemToReplace.originalName || itemToReplace.name,\n      originalPrice: originalPrice,\n      priceDifference: priceDifference\n    };\n    \n    console.log(\"Tool::Script::\" + toolName + \" updated combo items:\", currentComboItems);\n    \n    // Calculate total price difference from all modifications\n    const totalPriceDifference = currentComboItems.reduce((sum, item) => {\n      return sum + (item.priceDifference || 0);\n    }, 0);\n    \n    // Get original combo base price (without previous modifications)\n    const comboMenuData = components.menu.getItemById(comboItem.menuItemId);\n    const originalComboPrice = comboMenuData ? comboMenuData.price : comboItem.basePrice;\n    const newComboPrice = originalComboPrice + totalPriceDifference;\n    \n    console.log(\"Tool::Script::\" + toolName + \" price calculation:\", {\n      originalComboPrice,\n      totalPriceDifference,\n      newComboPrice\n    });\n    \n    // Update the combo item\n    const updatedCombo = {\n      ...comboItem,\n      basePrice: newComboPrice,\n      totalPrice: newComboPrice * comboItem.quantity,\n      comboItems: currentComboItems\n    };\n    \n    // Update the cart item\n    components.cart.updateCartItem(input.comboCartItemId, updatedCombo);\n    \n    // Show notification\n    const priceChangeText = priceDifference > 0 ? ` (+$${priceDifference.toFixed(2)})` : \n                           priceDifference < 0 ? ` (-$${Math.abs(priceDifference).toFixed(2)})` : '';\n    \n    components.ui.showNotification(\n      `Replaced ${itemToReplace.originalName || itemToReplace.name} with ${newItem.name}${priceChangeText}`,\n      \"success\"\n    );\n    \n    // Get updated cart summary\n    const cartSummary = components.cart.getOrderSummary();\n    \n    return JSON.stringify({\n      success: true,\n      message: `Successfully replaced ${itemToReplace.originalName || itemToReplace.name} with ${newItem.name}`,\n      comboItems: currentComboItems,\n      priceDifference: priceDifference,\n      totalPriceDifference: totalPriceDifference,\n      cartSummary: cartSummary\n    });\n    \n  } catch (error) {\n    console.error(\"Tool::Script::\" + toolName + \" error:\", error);\n    components.ui.showNotification(\"Failed to replace combo item\", \"error\");\n    return JSON.stringify({\n      success: false,\n      error: error.message\n    });\n  }\n}",
          "run_after_app_init": false,
          "order": 13
        }
      ],
      "globalParameters": [
        {
          "id": "param_1753890888050_uexjp4bps",
          "key": "menuAPIURL",
          "value": "/menu",
          "description": "",
          "order": 1
        },
        {
          "id": "param_1753891522025_vsdhfgd48",
          "key": "cartAPIURL",
          "value": "/cart",
          "description": "",
          "order": 2
        },
        {
          "id": "param_1753891782635_k7llqgtn6",
          "key": "orderAPIURL",
          "value": "/order",
          "description": "",
          "order": 3
        },
        {
          "id": "param_1753891819063_8glla4y33",
          "key": "loyaltyAPIURL",
          "value": "/loyalty",
          "description": "",
          "order": 4
        },
        {
          "id": "param_1755756463751_d3wty1lep",
          "key": "chatAPIURL",
          "value": "/chat",
          "description": "",
          "order": 5
        }
      ],
      "enableSentimentAnalysis": false,
      "autoInitiateConversation": false,
      "initiationAudio": "data:audio/webm;base64,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",
      "companyName": "AI Drive-thru"
    }
  }
}